{"title":"C++的 0/3/5 规则","uid":"075d1c2c16c349b3d7fc2304f4fb4b22","slug":"C++_0_3_5_rule","date":"2022-08-30T10:23:00.000Z","updated":"2022-08-30T11:26:00.000Z","comments":true,"path":"api/articles/C++_0_3_5_rule.json","keywords":null,"cover":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>编程三大错觉：<br>\n我比编译器聪明<br>\n我超越了标准库<br>\n我能管好内存</p></blockquote>\n<h2 id=\"问题描述\"><a class=\"markdownIt-Anchor\" href=\"#问题描述\">#</a> 问题描述</h2>\n<p>由于最近在看《算导》，我就萌生了实现算导的想法。之前实现的线表 List.h 文件一直稳定运作，但在经历了单元测试并稳定运行数天后，当我将它应用到我的新代码部分时，出现了一个 bug。<br>\n我的代码文件如下：<br>\nList.h</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template&lt;typename T&gt;\nclass List &#123;\npublic:\n    List() : head(new class Node&lt;T&gt;), tail(new class Node&lt;T&gt;) &#123;\n        head-&gt;nextNode &#x3D; tail;\n        tail-&gt;prevNode &#x3D; head;\n    &#125;\n\n    List(T rs) : List() &#123;\n        insert(rs);\n    &#125;\n\n    ~List() &#123;\n        for (class Node&lt;T&gt; *pointer &#x3D; tail; pointer !&#x3D; head;) &#123;\n            auto temp &#x3D; pointer;\n            pointer &#x3D; pointer-&gt;prevNode;\n            delete temp;\n        &#125;\n        delete head;\n    &#125;\n\t\n\tvoid insert(T rs)&#123;\n\t    auto pointer &#x3D; new class Node&lt;T&gt;(rs, tail-&gt;prevNode, tail);\n    \ttail-&gt;prevNode &#x3D; pointer;\n    \tpointer-&gt;prevNode-&gt;nextNode &#x3D; pointer;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>test.cpp</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template&lt;class Vertex, class Edge&gt;\nclass AdjacentList&#123;\nprivate:\n\tstd::map&lt;shared_ptr&lt;Vertex&gt;,List&lt;Edge&gt;&gt;;\n&#125;\n\ntemplate&lt;class Vertex, class Edge&gt;\nvoid AdjacentList&lt;Vertex, Edge&gt;::insert(std::shared_ptr&lt;Vertex&gt; origin, std::shared_ptr&lt;Vertex&gt; next, double w) &#123;\n    if (!graph[origin])\n        graph[origin] &#x3D; List&lt;Edge&gt;();\n    auto x &#x3D; Edge(next, w);\n    graph[origin].insert(x);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来给你三分钟，试试能不能找出 bug 在哪？</p>\n<p>如果你找不出 bug 在哪里，请接着往下看：<br>\nC++ 为我们提供了强大的智能指针，用来管理资源的生命周期。大部分情况下我们只要用好智能指针来管理资源就好。不过在某些情况下，我们可能会遇到空间不足，或是需要自定制的资源管理类。然而，编写资源管理类很困难，你很难检测和排除内存泄漏或空悬指针的现象。<br>\n回到我们上面的这个函数，bug 实际上出现在</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">if (!graph[origin])\n        graph[origin] &#x3D; List&lt;Edge&gt;();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这里。在这里，我们不是初始化，而是使用复制赋值运算符</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">ClassType &amp;operate&#x3D;(ClassType &amp;rs);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>为 map 的 second 值赋值。由于我们的 List 类并没有自定义复制赋值运算符，C++ 的默认复制赋值运算符的操作是将原来类的每一个成员变量赋值给新的类。所以这里， <code>graph[origin]</code>  得到了一个 <code>List&lt;Edge&gt;()</code>  类的 head 和 tail 指针（注意，这样非常危险！要么两个 List 在同一块链表上进行插入删除操作，要么造成内存泄漏的后果）<br>\n我们在 List 的 insert 函数处打一个断点，看看会发生什么：<br>\n<img src=\"https://res.cloudinary.com/dwy9slegd/image/upload/v1661856814/gxKom_ztdkff.png\" alt=\"debug1\"><br>\n 可以看到， <code>graph[origin]</code>  的 head 和 tail 的前后指针良好。但我们再执行一步看看：<br>\n<img src=\"https://res.cloudinary.com/dwy9slegd/image/upload/v1661856811/J6n22_szifw4.png\" alt=\"debug2\"><br>\n 你会发现：变量 pointer 竟指向一个 “已分配” 的指针 <code>graph[origin].head</code> ！这是为什么呢？<br>\n其实到这里问题已经比较清晰了：为 <code>graph[origin]</code>  赋值的 <code>List&lt;Edge&gt;()</code>  是一个右值，在完成赋值语句之后就被析构了。我们自定义的析构函数从 tail 开始逐个向前，将所有指针指向的资源释放掉。那为什么在 dubugger 这里还能看到 head、tail 和它们指向的值呢？这是因为编译器在将资源返回给动态内存池的时候不会执行置零操作，而是简单地将该地址入栈等待下一次调用。所以指向该地址的类仍然可以解释 ———— 虽然它早已被析构了。<br>\n那这种问题怎样解决呢？一种方式是正常调用它的构造函数以便之后调用成员函数：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">  if (!graph[origin])\n&#x2F;&#x2F;construct graph[origin]\n      graph[origin];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>但另一个更重要的操作是，更改 List 的类函数</p>\n<h2 id=\"035规则\"><a class=\"markdownIt-Anchor\" href=\"#035规则\">#</a> 0/3/5 规则</h2>\n<h3 id=\"零规则\"><a class=\"markdownIt-Anchor\" href=\"#零规则\">#</a> 零规则</h3>\n<p>规则的零部分规定，在创建类时，你可以不编写任何特殊成员函数（而由编译器默认生成）。</p>\n<h3 id=\"三规则\"><a class=\"markdownIt-Anchor\" href=\"#三规则\">#</a> 三规则</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果你的类需要任何</p>\n<ul>\n<li>一个复制构造函数，</li>\n<li>赋值运算符，</li>\n<li>析构函数，</li>\n</ul>\n<p>明确定义，那么很可能需要这三个。</p></blockquote>\n<p>因为它们三个通常都用于管理资源，如果你的类用来管理资源，则通常需要管理复制和释放。<br>\n如果复制类管理的资源没有良好的语义，则考虑通过将复制构造函数和赋值运算符声明为 <code>=delete;</code> （鼓励）或放入 private scope 并不进行定义。</p>\n<h3 id=\"五规则\"><a class=\"markdownIt-Anchor\" href=\"#五规则\">#</a> 五规则</h3>\n<p>在三规则的基础上，C++11 标准引入了右值。所以还需要考虑移动构造函数和移动赋值函数，即</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class ClassExample&#123;\npublic:\n\t~ClassExample() &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;\n\t\n\tClassExample(ClassExample &amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;\n\t\n\tClassExample(ClassExample &amp;&amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;\n\t\n\tClassExample &amp;operator&#x3D;(ClassExample &amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;\n\t\n\tClassExample &amp;operator&#x3D;(ClassExample &amp;&amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"代码改进\"><a class=\"markdownIt-Anchor\" href=\"#代码改进\">#</a> 代码改进</h2>\n<p>我们增加移动赋值操作的定义，可以练习一下其他几个函数的定义。<br>\n由于 List 类的 <code>head</code>  和 <code>tail</code>  为哨兵元素，我们无需考虑，也无需复制。而是将 List 类中的元素复制过来。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template&lt;typename T&gt;\nclass List &#123;\npublic:\n\tList&lt;T&gt; &amp;operator&#x3D;(List&lt;T&gt; &amp;&amp;rs)&#123;\n\t\t&#x2F;&#x2F;free this class&#39;s element but reserve guard elements\n\t\tfor(auto pointer &#x3D; tail-&gt;prevNode; pointer !&#x3D; head;)&#123;\n\t\t\tauto temp &#x3D; pointer;\n\t\t\tpointer &#x3D; pointer-&gt;prevNode;\n\t\t\tdelete temp;\n\t\t&#125;\n\t\t&#x2F;&#x2F;duplicate rs&#39; elements\n\t\tfor(auto pointer &#x3D; rs.head-&gt;nextNode; pointer !&#x3D; rs.tail; pointer &#x3D; pointer-&gt;nextNode)&#123;\n\t\t\tinsert(*pointer);\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","feature":true,"text":" 编程三大错觉： 我比编译器聪明 我超越了标准库 我能管好内存 # 问题描述 由于最近在看《算导》，我就萌生了实现算导的想法。之前实现的线表 List.h 文件一直稳定运作，但在经历了单元测试并稳定运行数天后，当我将它应用到我的新代码部分时，出现了一个 bug。 我的代码文件如下...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"},{"name":"coding过程中踩过的坑","slug":"技术笔记/coding过程中踩过的坑","count":2,"path":"api/categories/技术笔记/coding过程中踩过的坑.json"}],"tags":[{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"},{"name":"debug","slug":"debug","count":2,"path":"api/tags/debug.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\"> 问题描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#035%E8%A7%84%E5%88%99\"><span class=\"toc-text\"> 0&#x2F;3&#x2F;5 规则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E8%A7%84%E5%88%99\"><span class=\"toc-text\"> 零规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%A7%84%E5%88%99\"><span class=\"toc-text\"> 三规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E8%A7%84%E5%88%99\"><span class=\"toc-text\"> 五规则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B\"><span class=\"toc-text\"> 代码改进</span></a></li></ol>","author":{"name":"江子扬","slug":"blog-author","avatar":"https://res.cloudinary.com/dwy9slegd/image/upload/v1662327765/66617421_abqsge.jpg","link":"/","description":"我的肩上是风，风上是闪烁的星群","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LeetCode 1687. Delivering Boxes from Storage to Ports","uid":"f48f8a0014b621da7580e4b43233d5f7","slug":"1687. Delivering Boxes from Storage to Ports","date":"2022-09-02T02:31:00.000Z","updated":"2022-09-02T14:22:00.000Z","comments":true,"path":"api/articles/1687. Delivering Boxes from Storage to Ports.json","keywords":null,"cover":null,"text":"# Problem Discription You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a *...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"},{"name":"LeetCode笔记","slug":"技术笔记/LeetCode笔记","count":1,"path":"api/categories/技术笔记/LeetCode笔记.json"}],"tags":[{"name":"LeetCode","slug":"LeetCode","count":1,"path":"api/tags/LeetCode.json"},{"name":"Algorithms","slug":"Algorithms","count":1,"path":"api/tags/Algorithms.json"}],"author":{"name":"江子扬","slug":"blog-author","avatar":"https://res.cloudinary.com/dwy9slegd/image/upload/v1662327765/66617421_abqsge.jpg","link":"/","description":"我的肩上是风，风上是闪烁的星群","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"linux如何通过SMTP服务器发送QQ邮件","uid":"ee29397e7a9e190780aaf5555ff49a2e","slug":"linux如何通过SMTP服务器发送QQ邮件","date":"2022-06-28T10:23:00.000Z","updated":"2022-09-04T17:24:36.618Z","comments":true,"path":"api/articles/linux如何通过SMTP服务器发送QQ邮件.json","keywords":null,"cover":[],"text":"这是《计算机网络 —— 自顶向下方法》里的一个小实验，对理解 smtp 的交流和电子邮件的报头都很有帮助。是个很值得尝试的实验。 首先，我们需要下载 telnet sudo apt install telnetd -y 其次，按照这个文档所示的方式开启 QQ 邮箱的 SMTP 服...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"},{"name":"Computer Networking","slug":"技术笔记/Computer-Networking","count":1,"path":"api/categories/技术笔记/Computer-Networking.json"}],"tags":[{"name":"Web","slug":"Web","count":1,"path":"api/tags/Web.json"},{"name":"tutorial","slug":"tutorial","count":1,"path":"api/tags/tutorial.json"}],"author":{"name":"江子扬","slug":"blog-author","avatar":"https://res.cloudinary.com/dwy9slegd/image/upload/v1662327765/66617421_abqsge.jpg","link":"/","description":"我的肩上是风，风上是闪烁的星群","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}