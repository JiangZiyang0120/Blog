<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>历周记(2022-08-29 - 2022-09-04)</title>
    <url>//post/2022-W35.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这是我在博客上写的第一篇周记，希望能用周记的形式来记录自己的生活和一些感悟。也能用输出倒逼输入的方式让自己去更多地涉猎一些内容。我始终觉得文理科并不是人生必须二选一的选项，一个程序工程师同样需要人文情怀和人文素养，才能更好地开发出吸引和满足他人诉求的产品。<br>
我在上一周，乃至过去的一个月每天晚上都习惯性地开始写代码，一直熬到深夜解决问题才上床。然后被蓝光辐射地毫无困意，打开社交媒体刷刷刷，一直刷到昏昏沉沉地睡去。第二天被闹铃叫醒，也才堪堪睡够六个小时。时间一长，生物钟就彻底乱掉了，我开始间歇性嗜睡、感冒流涕不止，每日跑步也感觉跑不动了。这让我开始思考一个WLB(Work&amp;Life Balance) 的问题。这也是本次周记的话题。</p>
<h2 id="如何看待-wlb">如何看待 WLB</h2>
<p>对许多大学学生而言，我们对 WLB 其实缺乏清晰的认知。一方面，学生，尤其是大学生，并没有严格的工作与时间的界限。出于个人规划与目标的不同，日日刷图书馆者有之，爆肝做项目者有之，每天摸鱼直到考试周熬夜补天者亦有之。  另一方面，学生的工作时间往往不怎么受到重视（因为大学生是极好的廉价劳动力），时常是召之即来挥之即去，这也导致学生的工作/学习时间极不固定。<br>
这种大学生活虽给了我们极大的自由，让我们可以根据自己需求来分配时间，但我认为在某种程度上这并不是一种好事。一方面，我们需要养成对“工作”的概念，找到自己认可的，能够实现自我价值的事业，然后不断精进——注意，这里需要的是一种自发而自觉的工作；另一方面，我们也需要掌握调剂工作与生活的艺术，找到适合自己的工作节奏和享受生活的态度。从这种意义上来说，八小时工作制是一种很值得借鉴的生活方式——每日给工作留足一定的时间，剩下的时间用于享受生活（当然，也可以用于发展兴趣、探索不同于日常工作的，可以提升自己的那一部分），总之，与工作保留出足够的距离。以免过快地消耗自己的激情和发展潜力。<br>
在两天前，我终于堪堪调整好了自己的生物钟，也进一步规划好了自己的学习时间表。主要任务就是把自己的编程和学习计算机知识的活动调到下午，以免自己沉迷学习无法自拔，再次陷入熬夜的不良循环中去。但是终极目标仍然是坚持自己的时间表，不要为任务所困。到点后，记录完自己的状态和todo-list，然后迅速回归生活。不要陷入周期性的<a href="https://asana.com/zh-tw/resources/parkinsons-law">帕金森</a>危机中去。</p>
<h2 id="时间冗余的最大杀手">时间冗余的最大杀手</h2>
<p>该条引自<a href="https://twitter.com/Svwang1">硅谷王川</a>的推特：</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>最重要的一个冗余是时间冗余，有大把的闲暇时间去做自己愿意做的事情，而把在不愿意做的事情上耗费的时间尽量压缩到接近于零。</p>
<p><strong>时间冗余的第一个杀手是：浪费时间去辩论，或试图说服认知不同的人接受自己的观点。</strong></p>
<p>时间冗余的第二个杀手，是没有把自己经常要做的一些事情自动化，然后发现自己忘了，又要耗费时间精力再人工干预。</p>
<p>时间冗余的第三个杀手，<strong>是没有注重于可以不断多次重复使用，积累的行为；而耗费大量精力在低价值，无法重复利用的行动上。</strong></p>
<p>时间冗余的第四个杀手，是没有勇气和意愿隔断各种低效甚至有伤害性的社交应酬，让一些 sb 随便的接近你的空间，或者允许一些群体的错误风气潜移默化的干扰你的独立思考。</p>
<p>时间冗余的第五个杀手，是没有注意“节制饮食 - 适度运动 - 充足睡眠&quot;, 随着年龄增长，各种肩酸背痛，视力下降，神经衰弱，高血糖血脂，心血管等毛病不断加剧，恶性循环，脾气也越发暴戾，迅速滑向老年痴呆，成了一个事实上的废人。</p>
<p>时间冗余的第六个杀手，是本来可以花 N 小时把一个事情做得差不多足够好就收手了，硬是要花 3N, 4N 甚至更多倍的时间，仅仅把效益再提高百分之几而已，甚至画蛇添足，多余的努力反而把事情搞砸了。</p>
<p>判断自己&quot;时间冗余&quot;的水平的一个角度是，你如果什么都不做，一个月，三个月，甚至像 Rip Van Winkle 一样睡很多年的觉再醒来，你的状况 (财务或者别的方面) 是不是可以维持现状，甚至会变得比现在更好? 如果有哪些地方需要人工干预，是否可以现在就未雨绸缪，把它预先自动设置好？</p>
<p>“时间冗余”并不完全等同于“高效率”，另一个角度是当意识到自己的方向是错误的时候，可以迅速调整纠错的能力。如果方向错误，意识到错误后因为各种限制而无法迅速抽身离开，那么不管效率多高，也是枉然。</p>
<p>任何事情，如果不能随时抽身离去，而要时常事必躬亲，是一个潜在的时间上的负资产，是对时间冗余的巨大损害。往往一开始没有在意，出了问题后才意识到代价巨大。</p></blockquote>
<p>我们往往意识不到时间是多么地宝贵，以致于将它轻掷到那些没有价值的地方去，陷入无底的时间漩涡无法自拔。我非常认可这个“时间冗余”的做法，以前也花了很多的经历来探索“自动化工具流”。但这段话的确给了我更多的启示：将时间浪费地画在不值得的地方同样是一种不负责任。如果必须浪费时间，那就将时间浪费给自己和自己爱的人身上吧。若是无谓地虚掷时间而想要获得快乐，斯以伐根而求木茂，塞源而欲流长也。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>周记</category>
      </categories>
      <tags>
        <tag>weekly journal</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1687. Delivering Boxes from Storage to Ports</title>
    <url>//post/1687.%20Delivering%20Boxes%20from%20Storage%20to%20Ports.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="problem-discription">Problem Discription</h2>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a <span class="token bold"><span class="token punctuation">**</span><span class="token content">limit</span><span class="token punctuation">**</span></span> on the <span class="token bold"><span class="token punctuation">**</span><span class="token content">number of boxes</span><span class="token punctuation">**</span></span> and the <span class="token bold"><span class="token punctuation">**</span><span class="token content">total weight</span><span class="token punctuation">**</span></span> that it can carry.

You are given an array <span class="token code-snippet code keyword">`boxes`</span>, where <span class="token code-snippet code keyword">`boxes[i] = [ports​​i​, weighti]`</span>, and three integers <span class="token code-snippet code keyword">`portsCount`</span>, <span class="token code-snippet code keyword">`maxBoxes`</span>, and <span class="token code-snippet code keyword">`maxWeight`</span>.

<span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`ports​​i`</span> is the port where you need to deliver the <span class="token code-snippet code keyword">`ith`</span> box and <span class="token code-snippet code keyword">`weightsi`</span> is the weight of the <span class="token code-snippet code keyword">`ith`</span> box.
<span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`portsCount`</span> is the number of ports.
<span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`maxBoxes`</span> and <span class="token code-snippet code keyword">`maxWeight`</span> are the respective box and weight limits of the ship.

The boxes need to be delivered <span class="token bold"><span class="token punctuation">**</span><span class="token content">in the order they are given</span><span class="token punctuation">**</span></span>. The ship will follow these steps:

<span class="token list punctuation">-</span> The ship will take some number of boxes from the <span class="token code-snippet code keyword">`boxes`</span> queue, not violating the <span class="token code-snippet code keyword">`maxBoxes`</span> and <span class="token code-snippet code keyword">`maxWeight`</span> constraints.
<span class="token list punctuation">-</span> For each loaded box <span class="token bold"><span class="token punctuation">**</span><span class="token content">in order</span><span class="token punctuation">**</span></span>, the ship will make a <span class="token bold"><span class="token punctuation">**</span><span class="token content">trip</span><span class="token punctuation">**</span></span> to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no <span class="token bold"><span class="token punctuation">**</span><span class="token content">trip</span><span class="token punctuation">**</span></span> is needed, and the box can immediately be delivered.
<span class="token list punctuation">-</span> The ship then makes a return <span class="token bold"><span class="token punctuation">**</span><span class="token content">trip</span><span class="token punctuation">**</span></span> to storage to take more boxes from the queue.

The ship must end at storage after all the boxes have been delivered.

Return <span class="token italic"><span class="token punctuation">*</span><span class="token content">the <span class="token bold"><span class="token punctuation">**</span><span class="token content">minimum</span><span class="token punctuation">**</span></span> number of <span class="token bold"><span class="token punctuation">**</span><span class="token content">trips</span><span class="token punctuation">**</span></span> the ship needs to make to deliver all boxes to their respective ports.</span><span class="token punctuation">*</span></span>

<span class="token bold"><span class="token punctuation">**</span><span class="token content">Example 1:</span><span class="token punctuation">**</span></span>

<span class="token bold"><span class="token punctuation">**</span><span class="token content">Input:</span><span class="token punctuation">**</span></span> boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
<span class="token bold"><span class="token punctuation">**</span><span class="token content">Output:</span><span class="token punctuation">**</span></span> 4
<span class="token bold"><span class="token punctuation">**</span><span class="token content">Explanation:</span><span class="token punctuation">**</span></span> The optimal strategy is as follows:

<span class="token list punctuation">-</span> The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.

So the total number of trips is 4.
Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).

<span class="token bold"><span class="token punctuation">**</span><span class="token content">Example 2:</span><span class="token punctuation">**</span></span>

<span class="token bold"><span class="token punctuation">**</span><span class="token content">Input:</span><span class="token punctuation">**</span></span> boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
<span class="token bold"><span class="token punctuation">**</span><span class="token content">Output:</span><span class="token punctuation">**</span></span> 6
<span class="token bold"><span class="token punctuation">**</span><span class="token content">Explanation:</span><span class="token punctuation">**</span></span> The optimal strategy is as follows:

<span class="token list punctuation">-</span> The ship takes the first box, goes to port 1, then returns to storage. 2 trips.
<span class="token list punctuation">-</span> The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.
<span class="token list punctuation">-</span> The ship takes the fifth box, goes to port 3, then returns to storage. 2 trips.

So the total number of trips is 2 + 2 + 2 = 6.

<span class="token bold"><span class="token punctuation">**</span><span class="token content">Example 3:</span><span class="token punctuation">**</span></span>

<span class="token bold"><span class="token punctuation">**</span><span class="token content">Input:</span><span class="token punctuation">**</span></span> boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
<span class="token bold"><span class="token punctuation">**</span><span class="token content">Output:</span><span class="token punctuation">**</span></span> 6
<span class="token bold"><span class="token punctuation">**</span><span class="token content">Explanation:</span><span class="token punctuation">**</span></span> The optimal strategy is as follows:

<span class="token list punctuation">-</span> The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.
<span class="token list punctuation">-</span> The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.
<span class="token list punctuation">-</span> The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.

So the total number of trips is 2 + 2 + 2 = 6.

<span class="token bold"><span class="token punctuation">**</span><span class="token content">Constraints:</span><span class="token punctuation">**</span></span>

<span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`1 &lt;= boxes.length &lt;= 105`</span>
<span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 105`</span>
<span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`1 &lt;= ports​​i &lt;= portsCount`</span>
<span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`1 &lt;= weightsi &lt;= maxWeight`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="analyse">Analyse</h2>
<p>As the dynamic programming solution’s max time complexity is <img src="https://math.now.sh?inline=%5Ctext%20O%28n%5E2%29" style="display:inline-block;margin: 0;">. We could simply get the first solution:<br>
This Code comes from <a href="https://leetcode.com/linshan007/">linshan077</a>. And it is almost the best implement of DP. Where the trip assist to decline the cost of repeatedly judging <code>boxes[j][0] == boxes[j-1][0]</code> and <code>dp</code> is the common implement of dynamic programming.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution1 &#123;
public:
    int boxDelivering(vector&lt;vector&lt;int&gt;&gt;&amp; boxes, int portsCount, int maxBoxes, int maxWeight) &#123;
        vector&lt;int&gt; trips(boxes.size());
        trips[0] &#x3D; 0;
        for (int i &#x3D; 1; i &lt; boxes.size(); ++i) &#123;
            if (boxes[i][0] &#x3D;&#x3D; boxes[i-1][0]) &#123;
                trips[i] &#x3D; trips[i-1];
            &#125; else &#123;
                trips[i] &#x3D; trips[i-1]+1;
            &#125;
        &#125;
        &#x2F;&#x2F; dp[i+1] is minimum trips assuming i is the last box to deliver and will return to port afterwards. 
        vector&lt;int&gt; dp(boxes.size()+1);
        dp[0] &#x3D; 0;
        for (int i &#x3D; 0; i &lt; boxes.size(); ++i) &#123;
            dp[i+1] &#x3D; INT_MAX;
            int sum_weights &#x3D; 0;
            for (int j &#x3D; i; j&gt;&#x3D;0 &amp;&amp; i-j+1 &lt;&#x3D; maxBoxes; --j) &#123;
                sum_weights +&#x3D; boxes[j][1];
                if (sum_weights &gt; maxWeight) break;
                dp[i+1] &#x3D; std::min(dp[i+1], dp[j]+2+trips[i]-trips[j]);
            &#125;
        &#125;
        return dp.back();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>However, it got a TLE.  And we translate<code>min(dp[j]+2+trips[i]-trips[j])</code> into <code>2+trips[i]+min(dp[j]-trips[j])</code>. It turns to a question: find the minimum in a Slide window(Which we can easily solve by a deque with total time complexity <img src="https://math.now.sh?inline=%5Ctext%20O%28n%29" style="display:inline-block;margin: 0;">).</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution2 &#123;
public:
    int boxDelivering(vector&lt;vector&lt;int&gt;&gt;&amp; boxes, int portsCount, int maxBoxes, int maxWeight) &#123;
        vector&lt;int&gt; trips(boxes.size());
        trips[0] &#x3D; 0;
        for (int i &#x3D; 1; i &lt; boxes.size(); ++i) &#123;
            if (boxes[i][0] &#x3D;&#x3D; boxes[i-1][0]) &#123;
                trips[i] &#x3D; trips[i-1];
            &#125; else &#123;
                trips[i] &#x3D; trips[i-1]+1;
            &#125;
        &#125;
        vector&lt;long int&gt; weights(boxes.size()+1);
        weights[0] &#x3D; 0;
        for (int i &#x3D; 0; i &lt; boxes.size(); ++i) &#123;
            weights[i+1] &#x3D; weights[i]+boxes[i][1];
        &#125;
        vector&lt;int&gt; dp(boxes.size()+1);
        dp[0] &#x3D; 0;
        vector&lt;long&gt; weight(boxes.size()+1);
        weight[0] &#x3D; 0;
        for(int i &#x3D; 1; i !&#x3D; boxes.size()+1; ++i)
            weight[i] &#x3D; weight[i-1] + boxes[i-1][1];
        deque&lt;pair&lt;int,int&gt;&gt; dq;
        int temp, totalWeight, totalBoxes;
        int j &#x3D; 0;
        dq.push_back(&#123;0,dp[0] - trips[0]&#125;);
        dp[1] &#x3D; 2 + trips[0] + dq.front().second;
        for (int i &#x3D; 1; i &lt; boxes.size(); ++i) &#123;
            temp &#x3D; dp[i] - trips[i];
            while (!dq.empty() &amp;&amp; dq.back().second &gt; temp)
                dq.pop_back();
            dq.push_back(&#123;i,temp&#125;);
            totalWeight &#x3D; weight[i+1] - weight[j];
            totalBoxes &#x3D; i - j + 1;
            while (totalWeight &gt; maxWeight || totalBoxes &gt; maxBoxes)&#123;
                dq.pop_front();
                j &#x3D; dq.front().first;
                totalWeight &#x3D; weight[i+1] - weight[j];
                totalBoxes &#x3D; i - j + 1;
            &#125;
            dp[i+1] &#x3D; 2 + trips[i] + dq.front().second;
        &#125;
        return dp.back();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The above code deducts the cost of  repetitive calculation of <code>dp[i+1] = std::min(dp[i+1], dp[j]+2+trips[i]-trips[j])</code> And turns <img src="https://math.now.sh?inline=%5Ctext%20O%28mn%29" style="display:inline-block;margin: 0;">(where m is the maxBoxes) into <img src="https://math.now.sh?inline=%5Ctext%20O%28n%29%20%2B%20%5Ctext%20O(n)%20%3D%20%5Ctext%20O(n)" style="display:inline-block;margin: 0;">.</p>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/1369248/C%2B%2B-DP-solution-with-thinking-process%3A-brute-force-greater-priority-queue-greater-mono-queue">C++ DP solution with thinking process: brute force -&gt; priority queue -&gt; mono queue</a></li>
<li><a href="https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/2330389/Java-or-From-O(N2)-to-O(N)-or-MonoQueue-w-DP">Java | From O(N^2) to O(N) | MonoQueue w/ DP</a></li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>LeetCode笔记</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的 0/3/5 规则</title>
    <url>//post/C++_0_3_5_rule.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>编程三大错觉：<br>
我比编译器聪明<br>
我超越了标准库<br>
我能管好内存</p></blockquote>
<h2 id="问题描述">问题描述</h2>
<p>由于最近在看《算导》，我就萌生了实现算导的想法。之前实现的线表List.h文件一直稳定运作，但在经历了单元测试并稳定运行数天后，当我将它应用到我的新代码部分时，出现了一个bug。<br>
我的代码文件如下：<br>
List.h</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
class List &#123;
public:
    List() : head(new class Node&lt;T&gt;), tail(new class Node&lt;T&gt;) &#123;
        head-&gt;nextNode &#x3D; tail;
        tail-&gt;prevNode &#x3D; head;
    &#125;

    List(T rs) : List() &#123;
        insert(rs);
    &#125;

    ~List() &#123;
        for (class Node&lt;T&gt; *pointer &#x3D; tail; pointer !&#x3D; head;) &#123;
            auto temp &#x3D; pointer;
            pointer &#x3D; pointer-&gt;prevNode;
            delete temp;
        &#125;
        delete head;
    &#125;
	
	void insert(T rs)&#123;
	    auto pointer &#x3D; new class Node&lt;T&gt;(rs, tail-&gt;prevNode, tail);
    	tail-&gt;prevNode &#x3D; pointer;
    	pointer-&gt;prevNode-&gt;nextNode &#x3D; pointer;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>test.cpp</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class Vertex, class Edge&gt;
class AdjacentList&#123;
private:
	std::map&lt;shared_ptr&lt;Vertex&gt;,List&lt;Edge&gt;&gt;;
&#125;

template&lt;class Vertex, class Edge&gt;
void AdjacentList&lt;Vertex, Edge&gt;::insert(std::shared_ptr&lt;Vertex&gt; origin, std::shared_ptr&lt;Vertex&gt; next, double w) &#123;
    if (!graph[origin])
        graph[origin] &#x3D; List&lt;Edge&gt;();
    auto x &#x3D; Edge(next, w);
    graph[origin].insert(x);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来给你三分钟，试试能不能找出bug在哪？</p>
<p>如果你找不出bug在哪里，请接着往下看：<br>
C++为我们提供了强大的智能指针，用来管理资源的生命周期。大部分情况下我们只要用好智能指针来管理资源就好。不过在某些情况下，我们可能会遇到空间不足，或是需要自定制的资源管理类。然而，编写资源管理类很困难，你很难检测和排除内存泄漏或空悬指针的现象。<br>
回到我们上面的这个函数，bug实际上出现在</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if (!graph[origin])
        graph[origin] &#x3D; List&lt;Edge&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里。在这里，我们不是初始化，而是使用复制赋值运算符</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ClassType &amp;operate&#x3D;(ClassType &amp;rs);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>为map的second值赋值。由于我们的List类并没有自定义复制赋值运算符，C++的默认复制赋值运算符的操作是将原来类的每一个成员变量赋值给新的类。所以这里，<code>graph[origin]</code>得到了一个<code>List&lt;Edge&gt;()</code>类的head和tail指针（注意，这样非常危险！要么两个List在同一块链表上进行插入删除操作，要么造成内存泄漏的后果）<br>
我们在List的insert函数处打一个断点，看看会发生什么：<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1661856814/gxKom_ztdkff.png" alt="debug1"><br>
可以看到，<code>graph[origin]</code>的head和tail的前后指针良好。但我们再执行一步看看：<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1661856811/J6n22_szifw4.png" alt="debug2"><br>
你会发现：变量pointer竟指向一个“已分配”的指针<code>graph[origin].head</code>！这是为什么呢？<br>
其实到这里问题已经比较清晰了：为<code>graph[origin]</code>赋值的<code>List&lt;Edge&gt;()</code>是一个右值，在完成赋值语句之后就被析构了。我们自定义的析构函数从tail开始逐个向前，将所有指针指向的资源释放掉。那为什么在dubugger这里还能看到head、tail和它们指向的值呢？这是因为编译器在将资源返回给动态内存池的时候不会执行置零操作，而是简单地将该地址入栈等待下一次调用。所以指向该地址的类仍然可以解释————虽然它早已被析构了。<br>
那这种问题怎样解决呢？一种方式是正常调用它的构造函数以便之后调用成员函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">  if (!graph[origin])
&#x2F;&#x2F;construct graph[origin]
      graph[origin];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但另一个更重要的操作是，更改List的类函数</p>
<h2 id="0-3-5规则">0/3/5规则</h2>
<h3 id="零规则">零规则</h3>
<p>规则的零部分规定，在创建类时，你可以不编写任何特殊成员函数（而由编译器默认生成）。</p>
<h3 id="三规则">三规则</h3>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>如果你的类需要任何</p>
<ul>
<li>一个复制构造函数，</li>
<li>赋值运算符，</li>
<li>析构函数，</li>
</ul>
<p>明确定义，那么很可能需要这三个。</p></blockquote>
<p>因为它们三个通常都用于管理资源，如果你的类用来管理资源，则通常需要管理复制和释放。<br>
如果复制类管理的资源没有良好的语义，则考虑通过将复制构造函数和赋值运算符声明为<code>=delete;</code>（鼓励）或放入 private scope 并不进行定义。</p>
<h3 id="五规则">五规则</h3>
<p>在三规则的基础上，C++11标准引入了右值。所以还需要考虑移动构造函数和移动赋值函数，即</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class ClassExample&#123;
public:
	~ClassExample() &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;
	
	ClassExample(ClassExample &amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;
	
	ClassExample(ClassExample &amp;&amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;
	
	ClassExample &amp;operator&#x3D;(ClassExample &amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;
	
	ClassExample &amp;operator&#x3D;(ClassExample &amp;&amp;) &#x3D; &#123;&#x2F;*details or default*&#x2F;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="代码改进">代码改进</h2>
<p>我们增加移动赋值操作的定义，可以练习一下其他几个函数的定义。<br>
由于List类的<code>head</code>和<code>tail</code>为哨兵元素，我们无需考虑，也无需复制。而是将List类中的元素复制过来。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
class List &#123;
public:
	List&lt;T&gt; &amp;operator&#x3D;(List&lt;T&gt; &amp;&amp;rs)&#123;
		&#x2F;&#x2F;free this class&#39;s element but reserve guard elements
		for(auto pointer &#x3D; tail-&gt;prevNode; pointer !&#x3D; head;)&#123;
			auto temp &#x3D; pointer;
			pointer &#x3D; pointer-&gt;prevNode;
			delete temp;
		&#125;
		&#x2F;&#x2F;duplicate rs&#39; elements
		for(auto pointer &#x3D; rs.head-&gt;nextNode; pointer !&#x3D; rs.tail; pointer &#x3D; pointer-&gt;nextNode)&#123;
			insert(*pointer);
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>coding过程中踩过的坑</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>linux如何通过SMTP服务器发送QQ邮件</title>
    <url>//post/linux%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81QQ%E9%82%AE%E4%BB%B6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这是《计算机网络——自顶向下方法》里的一个小实验，对理解smtp的交流和电子邮件的报头都很有帮助。是个很值得尝试的实验。</p>
<p>首先，我们需要下载 telnet</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt install telnetd -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其次，按照这个文档所示的方式开启QQ邮箱的SMTP服务<br>
<a href="https://www.ujcms.com/documentation/351.html"># 使用QQ邮箱发送邮件，QQ邮箱的smtp设置</a><br>
并记住自己的身份认证密码。</p>
<p>接下来，打开linus系统的<strong>xshell</strong>（快捷键 ctrl+alt+T），输入以下命令：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">telnet smtp.qq.com 25<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>会看到如下返回：<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1657184045/Pasted_image_20220627002748_uocva7.png" alt="terminal"></p>
<p>依次输入以下命令：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">auth login  &#x2F;&#x2F;输入命令验证身份
334 VXNlcm5hbWU6  &#x2F;&#x2F;服务器返回Username:的base64编码符
******** &#x2F;&#x2F;输入自己邮箱号，例123456789@qq.com的base64编码值
334 UGFzc3dvcmQ6  &#x2F;&#x2F;服务器返回Password:的base64编码符
******** &#x2F;&#x2F;输入自己身份认证密码的base64编码值
235 Authentication successful  &#x2F;&#x2F;连接成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>base64编码可以上网随便找转换工具，保险起见邮箱号和身份认证密码分别用两个不同的网站编码。或自己写一个也行。</p>
<p>连接成功后就可以按照书上的步骤：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Helo ****  &#x2F;&#x2F;主机名，可填邮箱号
250-newxmesmtplogicsvrsza9.qq.com-9.21.152.27-66638923
250-SIZE 73400320
250 OK
mail from: &lt;123456789@qq.com&gt; &#x2F;&#x2F;填你的邮箱号
250 OK
rcpt to: &lt;123456789@gmail.com&gt;  &#x2F;&#x2F;填你想发送的邮箱号
250 OK
data
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;.
&#x2F;&#x2F;报头必不可少，否则可能被当成垃圾邮件退回
From: 123456789@qq.com
To: 123456789@gmail.com
Subject: It may be a huge joke!

Just a test
Could you reach this message?
.
250 OK: queued as.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>随后，就能成功收到这份邮件了！<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1657184045/Pasted_image_20220627004011_n06trm.png" alt="接收邮件"></p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>黎明静悄悄</title>
    <url>//post/%E9%BB%8E%E6%98%8E%E9%9D%99%E6%82%84%E6%82%84.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1>黎明静悄悄</h1>
<h2 id="子夜">子夜</h2>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>She was still too young to know that life never gives anything for nothing, and that a price is always exacted for what fate bestows.</p>
<p align="right"><i>Marie Antoinette: Bildnis eines mittleren</i></p></blockquote>
<p>在我年纪尚小时，平日总喜欢抱着一本书看，大概是为了消遣，也有些文青情怀还未退却。可惜我对文学的热爱并不如何浓郁——它远不能使我埋头案牍皓首穷经，顶多是让我读两本入门门槛不那么高，与他人闲聊时能引那么一两句的图书罢了。而且很明显我的筛选能力也并不强——每当有女孩子看见我在读书，凑过来问一句：“你在读什么书啊？”，不出意外她们总会被书名吓走。即使出了意外，她们也大概率被我接下来尝试概括书本内容的话吓走——这证明我对门槛的判断还是有点高了。</p>
<p>本节开头引的这句话出自斯蒂芬·茨威格的《断头皇后》。很显然，作为一个文青，我应该是在某一期的《意林》或《读者》上看到了这句话然后记了下来；至于这本书，那是万万不可能读的。当然，有些书读完以后，你确实能感觉到整本书唯一有价值的地方就是书封上写的那句“名言”——当然不是这本书，这本书我确实没读过。引这句话的缘由呢，是我一个朋友托我写文记录一件事情，他的事情让我想起了这句话。当然，后面会引的一些语句和写法，提前声明一下，都出于我之手。我的这个朋友是个纯理工直男，半点文学细菌都没有，后面的理工科术语都出自他之口。</p>
<p>故事的开头是惯例的假语村言、真事隐什么的，我们权称我的这个朋友叫yzj吧。早在十余天前，yzj正温温吞吞地赶着自己某门课程的大作业。彼时距ddl尚早，又兼大作业的要求很隐晦，不上手根本掂不出斤两。粗瞟了两眼要求文件的yzj仗着自己学过一点相关课程，会两句C++语法，不免有些飘飘然。尽管老师提醒在先，yzj总觉得自己不算所谓的“很多同学”。后来的事实证明了他的观点，yzj确实不算很多同学，而是正态分布曲线最左边的那一撮。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908023538649_axllra.png" alt></p>
<p>总而言之，yzj在ddl十余天前才新建了名为finalproject的文件夹，开始了造轮子之旅。起初为了写得顺手，他按照matlab的操作方式写了个矩阵类，这个类重载了很多方法，也写了一些基本的计算，加了很多语法糖。据yzj表示，这是他后面写其他代码时唯一的慰籍，用起来太顺手了。而且这个类一个很大的好处就是漂亮，很好地遵循了设计模式，也针对性能做了很多优化。不过据他反思，在项目完成前就搞优化是大忌，属于新手小白最容易犯的错误之一。这个很漂亮的轮子花了他很多时间，等到他真的开始接触核心计算代码时，时间已经不允许他设计漂亮的类了。</p>
<h2 id="鸡鸣">鸡鸣</h2>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>Is life always this hard, or is it just when you’re working on your ddl?</p>
<p>Always like this.</p>
<p align="right"><i>re-creation from Léon</i></p></blockquote>
<p>其实设计不了漂亮的类不算一个大问题。虽然就yzj所言，他设计了一个封装地油盐不进丝毫不漏的类用来储存数据，后来才发现很多函数、方法都要用到这里面的数据，不得不设计一个个奇怪的接口以供操作；最后甚至恨不得把private scope改成public scope一劳永逸。然而就笔者来看，这对治疗我这个朋友吹毛求疵的审美洁癖简直是大功一件。而且我这个朋友写出来的拙劣代码，这辈子都不可能有第二个人去看了（哦，除了这门课的可怜助教，may destiny bless him），也免得拖累别人，小问题小问题。</p>
<p>在我看来，更大的问题在于,你要先解决一个问题，然后才再考虑如何漂亮地解决问题。我这个朋友时常拎不清这两者之间的关系。这在平日里他自学一些东西的时候问题倒也不大，有充足的时间拿来处理细节。而且他自学的时候总是拿经典教材一张张地翻过去，这些教材总是事无巨细地列出所有细节，这往往可以解答yzj的困惑。然而实操项目时，问题就变得不可控了起来。遇到的问题往往很偏，也没有足够详细的解决方案；网上的教程多半杂拼乱凑不求甚解，yzj甚至遇到几个Google都没办法解答的bug。这种时候一般人会换个方法或思路，但我这个朋友，他还有强迫症——什么人呐这是——他会继续死磕，直到撞南墙为止。举个例子，yzj一开始想自己写绘图包，尝试了两天发现自己水平不够，于是换了一个开源的绘图包。这个包倒是能跑，可惜太丑，yzj不满意，跑去写python绘图逻辑。写完后他一拍大脑想搞嵌入代码，遂迷之自信地跑去跑去看Cython tutorial，网上的教程很少，也解决不了yzj的问题，他又跑去看Cython Document。被环境变量绕晕后又跑去看CMake Document（他强烈要求我不告诉你们，他一开始还看了几天Makefile Document）。一番下来，几天光阴虚度，项目一点没做。纵观yzj的整个项目流程，基本上都耗在这种细枝末节但往往耗费巨细的地方上了。对了，yzj表示Cython确实很有意思，想填到自己的技术栈里。既然大作业ddl已经结束了，接下来他大概会继续看Cython Document并写些博客笔记什么的吧。</p>
<p>总之我这个朋友身上还有些学生思维没转变过来，这我得好好劝劝他。</p>
<p>站在一个旁人的角度，上面的话语可能有些平淡，好像在讲述一个平平无奇的故事。然而站在当事人的角度，时间的流逝却是无比真切的。每天显示屏左下角的日期都会跳一个数字，这昭示着自己可以拿来赶ddl的时间又少了一天。屏幕左上角的todo-list也总有一两个任务变成红色——这意味着他没有在自己设定的期限前完成这个模块。我的这个朋友，不知道出于压力还是什么原因，停掉了晚上的跑步，和其他人的聊天也会尽快结束掉，每天晚上睡觉越来越迟，第二天中午才能醒来；日常活动也变成了每天两次的取外卖。可惜他发质好，就这样的生活过了几天都不掉头发，殊为可气。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908163738_xhqv9u.jpg" alt></p>
<h2 id="平旦">平旦</h2>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>A half-million years in the future that twinkling of curiosity would have led his mind out into the universe to explore the mathematical mysteries of relativity. Now …</p>
<p align="right"><i>Dragon's Egg</i></p></blockquote>
<p>赶ddl的过程的确痛苦，然而当你发现其他人和你一样痛苦的时候，这种痛苦就会无形之中减轻一点。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908165420_zwxqgw.png" alt></p>
<p>当然，上述表情包纯属开玩笑。在yzj赶ddl中，发现这次大作业确实有点超纲，不少同学都表示难以下手。写累了和同在肝作业的同学&amp;朋友吐槽便成了yzj枯燥生活的少有的乐趣。果然世界上没有真正的感同身受，只有真的经此一劫，yzj才明白苏联笑话为什么会成为世界非遗。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908170757983_gr2gzm.png" alt></p>
<p>当然，也有大佬比较超脱，靠自己出色的英文文献阅读能力与代码能力一骑绝尘于yzj这等凡夫俗子。他的进度远快于其他人，也在ddl过程中给予了yzj足够的帮助。在此谨代表yzj向他致以深深的respect。</p>
<p>在各种各种调侃和帮助下，yzj还是慢慢地把自己的大作业做了出来。从一开始的望之不似人形的拟合图形到渐渐能看出大概轮廓，再到多少有那么一点感觉。（可以看出最后一张图还是有异常点，可能是出于计算机精度和异常矩阵的原因，或是还有yzj没有考虑到的bug；不过实在太累就没心情调了）</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908200114_dsy4ru.png" alt></p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908200123_adlhe8.png" alt></p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114185/QQ%E5%9B%BE%E7%89%8720210908200126_z2hzqn.jpg" alt></p>
<p>做出效果后，后面的题就好做了很多。前面的成果和轮子也能继续跑下去。yzj用最后仅剩的两三天时间紧赶慢赶地做完了后面的要求。</p>
<h2 id="破晓">破晓</h2>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>There is only one heroism in the world: to see the world as it is and to love it.</p>
<p align="right"><i>Romain Rolland</i></p></blockquote>
<p>时间来到了9月8日凌晨有余。离交作业的ddl还有约九个小时。这时候，yzj已经实现了大作业的基本要求，然而还有另外一些要求等待实现。“反正都熬了这么多天了，再熬一天把功能做完吧。”yzj心想，随机创建了一个新的header file，打开了文献和Google。</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908204043478_bdmuin.png" alt></p></blockquote>
<p>9月8日凌晨两点，yzj看完论文内的相关算法后又上Google搜了一下成熟的前置算法，发现自己即使刷穿了夜，也可能完不成剩下的内容了。在自己的document里放一个完成了一半，甚至没有可视化和可以供 clients 调用的 interface，纯靠不成体系的代码央求助教给点分实在不大体面。况且主要功能都做出来了，大部分的分都能拿到，索性直接交了，也免得掉头发。于是，yzj把代码又调试了最后一遍，检查了一下自己的document，将它们打包好，邮件发给了助教。粗算了一下，最终文件一共1300行左右的代码量，4.5kb的测试用例（考虑到代码写得实在太烂的因素，有效代码可能要打对折或三分之一）。这的确只是一个小的不能再小的项目代码量了，但对于没多少项目经验的yzj来说，这确实是一个值得一提的挑战。这也提醒了yzj，还是要注意项目经验的积累。</p>
<p>据yzj表示，当他点击了邮箱界面那个小小的【发送】按钮，只觉得浑身的负担一扫而空。他几乎在一瞬间就忘掉了发现自己没办法实现大作业其他要求时的懊恼。这也让他有点想到，让自己这么多天熬夜和自闭的压力究竟来自于哪里。</p>
<p>一身轻后，yzj还是没有什么睡意，于是打开了一个文档，想记录一下自己的心情。yzj刚选上课时，这门课的老师就曾提醒过大家，这门课比较难，需要付出更多的努力，也随之能够获得更多的收获。在上课的过程中，yzj的确感受到了这门课老师想要传道授业的苦心。他一遍又一遍地向大家阐述道：“数学是美的，学数学是探寻美发现美的过程，而非死记硬背的过程。”然而奈何yzj愚且鲁，不能体会到所谓的数学之美。但在做这门大作业的过程中yzj确实学到了很多知识。有了一个代码量合适的可以训练自己 C++ programing language 的机会，也了解了一些和编译器知识，可以和更底层的东西打交道。也被老师安利了linux系统并被深深吸引（linux ubuntu真的超级赞，都去试！）。然而学到这么多东西的过程却并非是在课程中，而是在自己独自做大作业的过程中。这个老师的角色更像是一个鞭策者，用一门有些超纲的大作业促使yzj继续学下去。嗯，其实也有榜样的作用，对yzj来说，这个老师身上的认真，和他对待自己热爱的东西时的态度简直自带光环。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908211520814_reitge.png" alt></p>
<p>约凌晨四点，同样选了这个老师课的室友也完成了自己的大作业。他拍了拍yzj的肩头，轻轻说了声：“我先睡了。”yzj点了点头。看了看窗外，已经有点微曦的晨光了。黎明静悄悄的，只有偶尔传来的极轻微的鸟鸣。</p>
<p>又是新的一天了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>informal essay</tag>
      </tags>
  </entry>
  <entry>
    <title>链接器查找范围</title>
    <url>//post/%E9%93%BE%E6%8E%A5%E5%99%A8%E6%9F%A5%E6%89%BE%E8%8C%83%E5%9B%B4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1>解决Visual Studio的 LNK2019 和 LNK1120 错误</h1>
<h2 id="问题描述">问题描述</h2>
<p>写了一个 text searching 的代码。该代码设计了数个类，并有一个 interface class 通过指向 base class 的 shared_ptr 通过 dynamic binding 来运行。然而结构设计的不是特别好，这也就导致我遇到了下面的问题：</p>
<span id="more"></span>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>interface class header file：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>interface class source file</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span>query<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// details</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>base class header file, which is included by interface class header file</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">QueryResult</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">//下面的语句是错误来源</span>
		<span class="token keyword">friend</span> <span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//details</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>
<p>接着在尝试运行时就发现了 <a href="https://docs.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2019?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(LNK2019)%26rd%3Dtrue&amp;view=msvc-160">LNK2019</a> 和 <a href="https://docs.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk1120?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(LNK1120)%26rd%3Dtrue&amp;view=msvc-160">LNK1120</a> 错误。以下为错误描述：</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>无法解析的外部符号 “class std::basic_ostream&lt;char,struct std::char_traits<char> &gt; &amp; __cdecl operator&lt;&lt;(class std::basic_ostream&lt;char,struct std::char_traits<char> &gt; &amp;,class QueryResult const &amp;)” (??6@YAAEAV?<img src="https://math.now.sh?inline=basic_ostream%40DU%3F" style="display:inline-block;margin: 0;">char_traits@D@std@@@std@@AEAV01@AEBVQueryResult@@@Z)，函数 main 中引用了该符号</char></char></p></blockquote>
<h2 id="尝试分析">尝试分析</h2>
<p>根据错误描述，可以锁定错误出自上面的第一行代码。Visual Studio给出的错误是无法解析，这样一个错误描述有些宽泛，放到 dev cpp 里就会好得多，它的错误提示长下面这样子：</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>[警告] inline 函数 ‘std::ostream&amp; 运算符&lt;&lt;(std::ostream&amp;, const QueryResult&amp;)’ used but never defined</p></blockquote>
<p>然而我一开始并没有用 dev ，而是自己看 web 调了半天，还找了我的两个同学帮我看了一下。他们的解决方案是把 source file 给 include 进来（这也让我有点吃惊，为什么大二的计科同学会没有 package 的概念）。这样的方案我显然没办法满意，我无法理解，为什么编译器会找不到一个已经 declaration 并且 defining 的函数。出于这种疑惑，我友善地提醒了一下编译器——产生了我的第一个解决方案：</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>interface class header file：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">extern</span> std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote>
<p>不得不说vs的 MSVC 编译器是真的强大，加个 extern 就能联想到同名的inline函数。如果我没有写这个blog的话，我也许会沾沾自喜于这个解决方案并且依然想破头皮都想不明白为什么会出现这种错误。直到我为了验证这个错误用 dev 上又跑了一遍。我的 dev 编译器是 g++ （版本我也不是很清楚，小白都是一键装环境的），没有这么智能，很实诚地提醒了我。由于 <code>operator&lt;&lt;</code> 函数需要调用 QueryResult object 的 members ，再加上这个函数最开始是在base_Query.h 里 declaration 的，且我的 Query.h has included the base_Query.h，所以编译器找到了 inline 版本的 declaration ，而很不幸，这个函数我没有定义。于是，我得到了第二个解决方案：</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>base class header file, which is included by interface class header file</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">QueryResult</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">//该文件前面的 declaration 也要改</span>
		<span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//details</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>
<p>顺便提一下我的下一个问题：为什么我会在 base_Query.h 里加上 inline 并且在后面的文件里忘记呢？</p>
<p>此事说来话长。我的C++是从《C++ Primer》入门的。在这本书里， Lippman 很细致地讲述了 inline 的作用（也就是没啥作用），但他的示例代码里还是会习惯性地带上 inline ，这个习惯也影响到了我。事实上，我原来的 source file 里全部加了 inline declaration ，这使得我一开始遇到的错误比现在多得多——也同样因为这个原因，我只有将 interface class source file 也 include 进来才能工作。后来一个同学在 STFW （Searching The Fucking Web）后告诉我分离式编程不能使用 inline 。然后这个函数是唯一一个声明了两次的函数，所以被我忘记了（笑）。</p>
<p>关于为什么分离式编程不能使用inline可以看<a href="https://www.cnblogs.com/GodA/p/6554591.html">这里</a>，这个作者讲得非常细致。也希望我有一天能够变成这样的内容输出者。</p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>coding过程中踩过的坑</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ learning notes</title>
    <url>//post/C++%20learning%20notes.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1>C++ learning notes</h1>
<h2 id="generic-algorithm">Generic algorithm</h2>
<h3 id="lambda">lambda</h3>
<p>[capture list] (parameter list) -&gt; return type {function body}</p>
<p>we can ignore the <em>parameter list</em> and <em>return type</em>, but the <em>capture list</em> and the <em>function body</em> must be reserved</p>
<p>eg:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="dynamic-memory">dynamic memory</h2>
<h3 id="shared-ptr">shared_ptr&lt;&gt;</h3>
<p>use function make_shared&lt;&gt;()</p>
<h3 id="unique-ptr">unique_ptr&lt;&gt;</h3>
<p>must be initialized once the pointer is created</p>
<h3 id="weak-ptr">weak_ptr&lt;&gt;</h3>
<p>can be assigned</p>
<h3 id="allocator">allocator</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">allocator<span class="token operator">&lt;</span>string<span class="token operator">></span> alloc<span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
weak_ptr<span class="token operator">&lt;</span>string<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span> p<span class="token punctuation">;</span>		<span class="token comment">//provided p points to an object or be nullptr</span>
<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span>	<span class="token comment">//provided p points to an array or be nullptr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote>
<h2 id="copy-assign-and-destroy">Copy, Assign and Destroy</h2>
<h3 id="specific-member-function-to-control-above-three-operations">specific member function to control above three operations</h3>
<p>copy constructor</p>
<p>copy-assignment operator</p>
<p>move constructor</p>
<p>move-assignment operator</p>
<p>destructor</p>
<h3 id="copy-constructor">copy constructor</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">/*
    	*default defination in class body is inline
    	*if we don't hope so, we need to define "= default" out of the class body
    	*generally, function defined in class body is inline
    	*/</span>
    	<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//default constructor</span>
		<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//copy constructor</span>
    	<span class="token comment">//first parameter must be a reference, and almost always be a const reference</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo2</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">//explicit prevents implicit conversion</span>
    	<span class="token keyword">explicit</span> <span class="token function">Foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    	<span class="token keyword">explicit</span> <span class="token function">Foo2</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
    	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="copy-assignment-constructor">copy-assignment constructor</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token comment">/*
		*we define a copy-assignment constructor below
    	*keyword operator+symbol is an overloaded operator
    	*which defines an operator(like =,+,- and so on)
    	*/</span>
		Foo <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> f<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">this</span><span class="token operator">-></span>n <span class="token operator">=</span> f<span class="token operator">-></span>n<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    Foo f1<span class="token punctuation">,</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//f2 is default initialized</span>
    f1 <span class="token operator">=</span> f2<span class="token punctuation">;</span> <span class="token comment">//equals to f1(f2)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="stop-the-copy">stop the copy</h4>
<p>if we don’t want a copy operation, we need to define it as the <strong>delete function</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NoCopy</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        *"= delete" must be present when we firstly declare it.
        *
        *by the way, we can delete any functions(except the destructor),
        *thongh i haven't clearly understood its effect and affect.
        *one interesting and meaningful example is, if a class's member
        *can't be implicitly initialized, copied, assigned or destroied,
        *its implicit initializer's member function is deleted.
        *It prevents from creating indestructible object.
        *
        *principle: destructor can't be delete
        */</span>
        <span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token keyword">const</span> NoCopy <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>	<span class="token comment">//stop the copy</span>
        NoCopy <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NoCopy <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>	<span class="token comment">//stop the copy-assignment</span>
        <span class="token operator">~</span><span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        *we can put the copy constructor into private zone to prevent from copying it.
        *we need to declare it in the private zone first
        *then define it in the public zone.(in order to prevent friend use it)
        *however, this practice is not recommended.
        */</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="destructor">destructor</h3>
<p>destructor delete the resource used by objects, and destruct non-static elements</p>
<p>it is used whenever the object is destroyed</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>implicitly destruct a pointer won’t delete the object it points.</p>
<p>on the contrary, smart pointer is class type with destructor, thus it can delete the object</p></blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//destructor.this function can't be overloaded</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="principle">principle</h4>
<ul>
<li>define destructor before assuring weather it needs a destructor or not</li>
<li>if a class needs a copy constructor, it always need a copy-assignment constructor. And vice verse</li>
</ul>
<h3 id="copy-control-and-resource-management">copy control and resource management</h3>
<p>behave like a value: the copy and the original object is fully independent</p>
<p>behave like a pointer: the copy and the original object point to the same underlying data</p>
<h4 id="classes-which-behave-like-a-value">classes which behave like a value</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HasPtr</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
			<span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token comment">//every HasPtr's copy has its own string member with equal value</span>
		<span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token operator">:</span>
			<span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token comment">/*
		*most copy assignment constructor combines the function
		*of destructor and copy constructor.
		*
		*for instance, copy assignment constructor
		*destroys the left side object's resource as destructor,
		*and copies data from the right side object
		*to the left one like copy constructor
		*
		*if possible, copy assignment constructor should be exception safe.
		*which means when an exception occurs,
		*it can put the left side object in a meaningful state
		*/</span>
		HasPtr <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">delete</span> ps<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span>ps<span class="token punctuation">;</span>
		<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/*
*in this case, to ensure exception safety,
*we copy the right object's data first
*to ensure exception safety before assignment.
*then we delete the resource of the left object and execute assignment
*/</span>
HasPtr <span class="token operator">&amp;</span>HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">auto</span> newp <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ps<span class="token punctuation">;</span>
	ps <span class="token operator">=</span> newp<span class="token punctuation">;</span>
	i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="classes-which-behave-like-a-pointer">classes which behave like a pointer</h4>
<p>use reference count to control the underlying data</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HasPtr</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
			<span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token comment">//copy the pointer to ensure they point to the same underlying data</span>
		<span class="token comment">//increase the reference count</span>
		<span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token operator">:</span>
			<span class="token function">ps</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">use</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>use<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token operator">++</span><span class="token operator">*</span>use<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		HasPtr <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span>ps<span class="token punctuation">;</span>
		<span class="token keyword">int</span> i<span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>size_t <span class="token operator">*</span>use<span class="token punctuation">;</span> <span class="token comment">//reference count</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token class-name">HasPtr</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token operator">*</span>use <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">delete</span> ps<span class="token punctuation">;</span>
		<span class="token keyword">delete</span> use<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

HasPtr <span class="token operator">&amp;</span>HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">++</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>use<span class="token punctuation">;</span>

	<span class="token comment">//execute the left object's destructor</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token operator">*</span>use <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">delete</span> ps<span class="token punctuation">;</span>
		<span class="token keyword">delete</span> use<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">//execute assignment</span>
	ps <span class="token operator">=</span> rhs<span class="token punctuation">.</span>ps<span class="token punctuation">;</span>
	i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
	use <span class="token operator">=</span> rhs<span class="token punctuation">.</span>use<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="swap">swap</h3>
<p>we can swap the pointer to decrease extra memory allocation</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HasPtr</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>HasPtr <span class="token operator">&amp;</span><span class="token punctuation">,</span> HasPtr <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
*if a menber of a class has its own swap function,
*use the std::swap is an error
*and if we implicitly use swap function, the compiler use the overloaded one by default
*/</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>HasPtr <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>ps<span class="token punctuation">,</span>rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>i<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    HasPtr <span class="token function">h1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">h2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>h1<span class="token punctuation">,</span>h2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//use the overloaded one</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//tip:this function can't overload the HasPtr &amp;HasPtr::operator=(HasPtr &amp;rhs)</span>
HasPtr <span class="token operator">&amp;</span>HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>HasPtr rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//parameter is a copy, not a reference</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">//rhs is destroyed</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="move-constructor">move constructor</h3>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>library container, string and shared_ptr class support both move and copy operation</p>
<p>IO class and unique_ptr class can be moved, but can’t be copied</p></blockquote>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>rvalue reference must be bound to an rvalue. we get rvalue reference through &amp;&amp; instead of &amp;</p>
<p>rvalue reference must be bound to an object ready to be destroyed</p>
<p>therefore, we can freely move an rvalue reference resource to another object</p>
<p>moreover, we can bound a const lvalue reference to an rvalue, as well</p>
<p>expression returns an rvalue. But rvalue reference variate itself is a lvalue</p>
<p>eg:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>r3 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>r4 <span class="token operator">=</span> r3<span class="token punctuation">;</span> <span class="token comment">//illegal</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>all of them is legal except the last one</p></blockquote>
<p>std::move avails to use a lvalue as an rvalue. What’s more, we must recognize that executing move means we promote not to use the original element unless we assign or destruct it.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>r4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>r3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//legal</span>
<span class="token comment">//use std::move instead of move in order to prevent from potential naming conflict</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>an example of move constructor</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">StrVec</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//move operation shouldn't throw error</span>
<span class="token comment">//initializer take over resource of s</span>
	<span class="token operator">:</span> <span class="token function">elements</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>elements<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">first_feet</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>first_feet<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s<span class="token punctuation">.</span>elements <span class="token operator">=</span> s<span class="token punctuation">.</span>first_feet <span class="token operator">=</span> s<span class="token punctuation">.</span>cap <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> 
        							<span class="token comment">//brilliant!</span>
        							<span class="token comment">//get the spark of controlling dynamic memory!</span>
	<span class="token comment">//now destructing s is safe</span>
    <span class="token comment">//i wander weather we permit s to be meaningfully assigned, </span>
    <span class="token comment">//and after insperation, i find that void StrVec::push_back(const std::string &amp;)</span>
    <span class="token comment">//has considered this situation. Now both assignment and destruction is ligal.</span>
    <span class="token comment">//and at the same time we can't read its value</span>
    <span class="token comment">//(certainly i put the whole code into my cpp file to avoid making my notes bloated)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="move-assignment-constructor">move assignment constructor</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">StrVec <span class="token operator">&amp;</span>StrVec<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">//check self-assignment</span>
	<span class="token comment">//I guess this operation is designed to avoid freeing itself</span>
	<span class="token comment">//otherwise it may move meaningless data and put itself in a meaningless state</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//release itself</span>
		elements <span class="token operator">=</span> rhs<span class="token punctuation">.</span>elements<span class="token punctuation">;</span>
		first_feet <span class="token operator">=</span> rhs<span class="token punctuation">.</span>first_feet<span class="token punctuation">;</span>
		cap <span class="token operator">=</span> rhs<span class="token punctuation">.</span>cap<span class="token punctuation">;</span>
		<span class="token comment">//put rhs in a destructible state</span>
		rhs<span class="token punctuation">.</span>elements <span class="token operator">=</span> rhs<span class="token punctuation">.</span>first_feet <span class="token operator">=</span> rhs<span class="token punctuation">.</span>cap <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//copy and move operation's overload</span>
StrVec v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span>
v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span>					<span class="token comment">//copy assignment constructor</span>
StrVec <span class="token function">getVec</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//getVec returns an rvalue</span>
							<span class="token comment">//because getVec() dosen't return value instead of reference</span>
							<span class="token comment">//up to now getVec() is just a declaration</span>

v2 <span class="token operator">=</span> <span class="token function">getVec</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//move assignment constructor</span>
<span class="token comment">/*
*if we didn't define a move constructor
*the compiler will convert an rvalue reference to a const reference
*and call copy constructor
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="reference-qualifier">reference qualifier</h3>
<p>C++ permit us to assign value to a rvalue object(so weird)</p>
<p>eg:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//s1 = "a", s2 = "bbb";</span>
<span class="token comment">/*
*(s1 + s2) is an rvalue which never affects s1 and s2's value without assignment
*usually it is created by compiler and released soon
*the following expression execute:
*	create a string temp_s = s1 + s2 = "abbb";
*	assign "Wow" to temp_s and return "Wow";
*	assign "Wow" to s3;
* 	release temp_s
*Just from my own guess.If there's something wrong, I'll correct it
*/</span>
string s3 <span class="token operator">=</span> <span class="token punctuation">(</span>s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"Wow"</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> s3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>we can use the reference qualifier to enforce the left object is an lvalue or an rvalue</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token comment">//the &amp; in the back of parameter list enforce the left object is an lvalue</span>
		Foo <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span> 
	<span class="token comment">//</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Foo <span class="token operator">&amp;</span>Foo<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">&#123;</span>
	<span class="token comment">//</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	Foo <span class="token function">someMember</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span> <span class="token comment">//const should be in front of reference qualifier</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>reference qualifier and overloaded</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
		Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">//because object is an rvalue, we can change itself without any affection</span>
Foo <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">&#123;</span> 
	<span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//object is an lvalue, thus we can't affect its value</span>
Foo <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">&#123;</span>
	Foo <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="overloading-and-type-conversion">overloading and type conversion</h2>
<h3 id="basic-concept">basic concept</h3>
<ul>
<li>
<p>an operator function should be a member of a class or have at least than one class type parameter</p>
</li>
<li>
<p>which means we can’t overload operators acting on the build-in type</p>
</li>
<li>
<p>overloaded operator’s priority and associative law is the same as the original operator</p>
</li>
</ul>
<p><strong>operators can be overloaded</strong></p>
<table>
<thead>
<tr>
<th>+</th>
<th>-</th>
<th>*</th>
<th>/</th>
<th>%</th>
<th>^</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td></td>
<td></td>
<td>~</td>
<td>!</td>
<td>,</td>
<td>=</td>
</tr>
<tr>
<td>&lt;</td>
<td>&gt;</td>
<td>&lt;=</td>
<td>&gt;=</td>
<td>++</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>&gt;&gt;</td>
<td>==</td>
<td>!=</td>
<td>&amp;&amp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>+=</td>
<td>-=</td>
<td>/=</td>
<td>%=</td>
<td>^=</td>
<td>&amp;=</td>
<td></td>
</tr>
<tr>
<td></td>
<td>=</td>
<td>*=</td>
<td>&lt;&lt;=</td>
<td>&gt;&gt;=</td>
<td>[]</td>
<td>()</td>
</tr>
<tr>
<td>-&gt;</td>
<td>-&gt;*</td>
<td>new</td>
<td>new[]</td>
<td>delete</td>
<td>delete[]</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>operators can not be overloaded</strong></p>
<table>
<thead>
<tr>
<th>::</th>
<th>.*</th>
<th>.</th>
<th>? :</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="operators">operators</h3>
<p>there are various of operators overloading practice. and you know, <em>cujus rei demonstrationem mirabilem sane detexi. Hanc marginis exiguitas non caperet</em>.(I’m sure I’ve discovered a wonderful demonstration, but the space here is too small to fill it). so I write them all down in my practice .cpp file and just note some announcements there.</p>
<p>The essence of operator overloading is a function call. therefore we can’t save  the original order of evaluation and the short circuit evaluation. and that’s why we don’t advice you to overload comma, address, logic and, logic or.</p>
<p>when we define an operator as a member function, its left operand must be an object of the operator’s class.</p>
<p>operator(=), index([]), call(()), member accession(-&gt;) operator must be member function of class.</p>
<p>ostream(&lt;&lt;), istream(&gt;&gt;) can’t be member function.</p>
<p>index operator usually define two overloading versions, the const one and the nonconst one.</p>
<p>increase and decrease operators usually be set as member functions.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">strBlobPtr <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//preoperator</span>
strBlobPtr <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//postoperator</span>

strBlobPtr strBlobPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	strBlobPtr ret <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>if we overload the call operator, the object of this class is called function object, because we can call this object. function object is usually used as actual parameter of generic algorithm. moreover, <a href="https://blog.csdn.net/YangZejia0120/article/details/118713608?spm=1001.2014.3001.5501"><strong>lambda</strong></a> is an unnamed class’ unnamed object, whose call operator is overloaded by lambda’s function body.</p>
<p>liberty <strong>functional</strong> defines a succession of function class as templates. and they are listed below.</p>
<table>
<thead>
<tr>
<th>arithmetic</th>
<th>relation</th>
<th>logic</th>
</tr>
</thead>
<tbody>
<tr>
<td>plus<Type></Type></td>
<td>equal_to<Type></Type></td>
<td>logical_and<Type></Type></td>
</tr>
<tr>
<td>minus<Type></Type></td>
<td>not_equal_to<Type></Type></td>
<td>logical_or<Type></Type></td>
</tr>
<tr>
<td>multiplies<Type></Type></td>
<td>greater<Type></Type></td>
<td>logical_not<Type></Type></td>
</tr>
<tr>
<td>divides<Type></Type></td>
<td>greater_equal<Type></Type></td>
<td></td>
</tr>
<tr>
<td>modulus<Type></Type></td>
<td>less<Type></Type></td>
<td></td>
</tr>
<tr>
<td>negate<Type></Type></td>
<td>less_equal<Type></Type></td>
<td></td>
</tr>
</tbody>
</table>
<p>operator <em>type</em>() const is class-type conversions or be named user-define conversions. it allows a type to be an object’s return type. this conversion is implicit.</p>
<p>we can define explicit conversion operator to control class-type conversion.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SmallInt</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">SmallInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
		<span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

SmallInt si <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>si<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">//explicitly request for type conversion</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>however, if the conversion is used as a condition, the compiler will automatically execute the conversion.</p>
<h3 id="function-table">function table</h3>
<p>function, function pointer, function class, lambda expression, classes built by bind and any other classes which has overloaded the call operator are all callable object. function class defined in liberty <strong>functional</strong> can be used to reserve callable object.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>

function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> add<span class="token punctuation">;</span>
<span class="token comment">//f1(4,2) == 6; //equal to add(4,2);</span>
<span class="token comment">//f1 == true;	//f1 has a callable object;</span>
function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>we can define a function table to reserve callable objects with same <em>retType(args)</em>.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span> binops <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">&#123;</span><span class="token string">"+"</span><span class="token punctuation">,</span> add<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>	<span class="token comment">//each element is a pair</span>
	<span class="token punctuation">&#123;</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">minus</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#123;</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#123;</span><span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#123;</span><span class="token string">"%"</span><span class="token punctuation">,</span> mod<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">//in this case, binos["+"](4,2) == 6;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="object-oriented-programming">Object-Oriented Programming</h2>
<h3 id="inheritance">inheritance</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Quote</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">Quote</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
		<span class="token function">Quote</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>book<span class="token punctuation">,</span> <span class="token keyword">double</span> sales_price<span class="token punctuation">)</span><span class="token operator">:</span>
			<span class="token function">bookNo</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">price</span><span class="token punctuation">(</span>sales_price<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> bookNo<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">//key word virtual defines a virtual function</span>
		<span class="token comment">//which means the base class permits drived classes to override it</span>
		<span class="token keyword">virtual</span> <span class="token keyword">double</span> <span class="token function">net_price</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> n <span class="token operator">*</span> price<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
    	<span class="token comment">//moreover, if we don't wish our clients use the base class' member function</span>
    	<span class="token comment">//we need to define this member function to be a pure virtual function as the following code row</span>
    	<span class="token comment">//notice :the pure virtual function can only be defined in the declaration body</span>
    	<span class="token keyword">virtual</span> <span class="token keyword">double</span> <span class="token function">net_price</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
		<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Quote</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//dynamically bind destructor</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
		<span class="token comment">/*
		*key word protected serves for those members
		*which are not supposed to be used by object's users
		*but needed to be used by derived class
		*/</span>
	<span class="token keyword">protected</span><span class="token operator">:</span>
		<span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>		<span class="token comment">//common price without discount</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/*
*type of class derivation list:colon and a list of base class
*whose type is base class behind optional assess specifire
*and splited by comma
*/</span>
<span class="token keyword">class</span> <span class="token class-name">Bulk_quote</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Quote</span></span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">Buli_quote</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
		<span class="token function">Built_quote</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">/*
		*key word override explicitly declare that this member function
		*will be used to redefine the base class' virtual function
		*if not, the compiler will throw error
		*/</span>
		<span class="token keyword">double</span> <span class="token function">net_price</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token comment">//the minimum purchase quantity of discount</span>
		std<span class="token double-colon punctuation">::</span>size_t min_qty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">double</span> discount <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>because derived class has its base class member, compiler can implicitly convert it into its base class as a reference or pointer. On the contrary, compiler doesn’t allow us to implicitly convert base class object into derived class object. However, if we ensure this action’s safety, we can use <strong>static_cast</strong> enforce the conversion. But this action is not recommended. What’s more, if the base class has at least one virtual function, we can use <strong>dynamic_cast</strong> to check this conversion’s safety and let the compiler divides whether allow or not.</p>
<p>if a base class defines a static member, the whole inheritance system has only one instance no matter how many derived classes and objects have been defined.</p>
<p>base class must be defined before defining derived classes.</p>
<p>key word <strong>final</strong> restrict us from using a class as base class. key word <strong>final</strong> can be used to declare that a virtual function is the final function, which means this function can’t be overrode.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NoDerived</span> <span class="token keyword">final</span> <span class="token punctuation">&#123;</span><span class="token comment">/*details*/</span><span class="token punctuation">&#125;</span>
<span class="token comment">//illegal, we can't use Noderived as a base class</span>
<span class="token keyword">class</span> <span class="token class-name">Bad</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">NoDerived</span></span> <span class="token punctuation">&#123;</span><span class="token comment">/*details*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>virtual function can have acquiescent parameters, and its acquiescent parameters depend on the static type of the call.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">funcion</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/*details*/</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">&#123;</span><span class="token comment">/*details*/</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">execuse_function</span><span class="token punctuation">(</span>Base <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	b<span class="token punctuation">.</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	Derived d<span class="token punctuation">;</span>
	<span class="token function">execuse_function</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//execuse Base::function(int a = 0, int b = 1);</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="scope">scope</h3>
<p><strong>notions:</strong></p>
<ul>
<li>iff the derived class publicly inherits base class can users use the conversions between derived class and base class.</li>
<li>if the derived class publicly or protected inherits base class, the derived class can use the conversions.</li>
<li>if the derived class privately inherits base class, the derived class’ objects and friends can’t use the conversions.</li>
<li>friend relationship can’t be inherited.</li>
<li><strong>each class controls its members’ accessible permissions.</strong></li>
<li>if we need to change a member’s accessible permission, we can use the <em>using</em> declaration in the corresponding action scope</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
	<span class="token keyword">protected</span><span class="token operator">:</span>
		std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//we inherit the base class in the private scope</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token comment">//then Base::size() is public </span>
		<span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>size<span class="token punctuation">;</span>
	<span class="token keyword">protected</span><span class="token operator">:</span>
		<span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>acquiescent derived scope operators depend on class’ type. struct acquiescently owns public scope while class having private scope.</p>
<p>derived class’ scope is combined into base class’ scope. thus derived class’ member with the same name as base class’ has higher priority.</p>
<p>name lookup precedes type lookup. function declared in the inner scope won’t override but cover the outer scope’s function.(which remind us to use the <em>override</em> key word. otherwise we must ensure that the derived class’s function has the same parameters list as the base class’)</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> <span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">struct</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token comment">//Base's scope operator is public</span>
	<span class="token keyword">int</span> <span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

Derived d<span class="token punctuation">;</span>
Base b<span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//error:Base::memfunc() is hided. the right way is written below</span>
d<span class="token punctuation">.</span><span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">memfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="dynamic-binding">dynamic binding</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">print_total</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span>
                   <span class="token keyword">const</span> Quote <span class="token operator">&amp;</span>item<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">//calling Quote::net_price or Bulk_quote::net_price</span>
	<span class="token comment">//depends on item's object type</span>
    <span class="token comment">//moreover, accessible members which we can use depend on the static type</span>
    <span class="token comment">//for instance, this item below has no right to use Bulk_quote's unique public members</span>
	<span class="token keyword">double</span> ret <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">net_price</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	os <span class="token operator">&lt;&lt;</span> <span class="token string">"ISBN: "</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	   <span class="token operator">&lt;&lt;</span> <span class="token string">"# sold: "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">"total due: "</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//if we don'y want to use dynamic binding, we need to explicitly declare the scope</span>
<span class="token keyword">double</span> ret <span class="token operator">=</span> item<span class="token operator">-></span><span class="token class-name">Quote</span><span class="token double-colon punctuation">::</span><span class="token function">net_price</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>now, we need to consider this situation where we delete a derived object pointed by a base class pointer. we must ensure that the delete command executes the derived object’s destructor. So we declare the base class’ destructor as a virtual function to solve this problem. what’s more, virtual destructor will impede generating movement operation.</p>
<p>What’s more, if we use containers to save objects, it is supposed to indirectly save it. An common usage is using pointer. Then we are able to use base class pointer calling derived objects.</p>
<h2 id="template">template</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">//key word:template</span>
  					  <span class="token comment">//&lt;template T> is template parameter list</span>
					  <span class="token comment">//template parameters are divided by comma</span>
<span class="token comment">/*
*moerover, key word typename is the same with key word class in this situation
*/</span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> v1<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> v2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">></span> v2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v2 <span class="token operator">&lt;</span> v1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//type parameter can be used as return type or parameter type</span>
<span class="token comment">//it can be used as variables declaration and type translation, as well</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	T tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
	<span class="token comment">//omitted details</span>
	<span class="token keyword">return</span> T<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
*we can define nontype parameter and the parameter's value is provided by
*clients or compiler
*in this case, compiler provide nontype parameters int values depends on
*const char array's length
*nontype parameter can be int, object/function pointer or lvalue reference
*/</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> N<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> M<span class="token operator">></span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
*template can be declared as inline or constexpr
*this declaration should be put between template parameter list and return type
*/</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">inline</span> T <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>principle</strong>: template function’s parameters are supposed to be const reference, which guarantees non-copyable object’s availability.</p>
<p>if we want to define a class member function out of the class body, it’s type should be:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token operator">></span>
<span class="token keyword">return</span><span class="token operator">-</span>type <span class="token keyword">class</span><span class="token operator">-</span>name<span class="token double-colon punctuation">::</span>member<span class="token operator">-</span><span class="token function">name</span><span class="token punctuation">(</span>parameter<span class="token operator">-</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>function<span class="token operator">-</span>bod<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>By default, template class’ member function is instantiated when it is called, which help us to use a template class even though there are some member function incompatible with a type, we can use part of class functions.</p>
<h3 id="friend-declaration">friend declaration</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//friend declaration</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Pal</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Pal</span><span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">//Pal instantiated by class C is a friend</span>
	<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Pal2</span><span class="token punctuation">;</span> <span class="token comment">//each instantiated Pal2 is C's friend</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C2</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Pal</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">;</span>
	<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">X</span><span class="token operator">></span> <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Pal2</span><span class="token punctuation">;</span><span class="token comment">//each instantiated Pal2 is each instantiated C2's friend</span>
									   <span class="token comment">//notice: friend's typename should be different from template class'</span>
	<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Pal3</span><span class="token punctuation">;</span> <span class="token comment">//Pal3 is a non-template class, every instantiated C2 is Pal3's friend</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//let template's typename as friend</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">C3</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">friend</span> T<span class="token punctuation">;</span> <span class="token comment">//type T is friend of C3 instantiated by T</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>if a template class contains static members, each type instantiated class has its own static members.</p>
<p>if we access a type name from a template class, we need to use the key word <strong>typename</strong> to explicitly ask compiler treats the name as a type name.</p>
<p>we can define default template argument, like code below.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">F</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>T<span class="token operator">>></span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> v1<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> v2<span class="token punctuation">,</span> F f<span class="token operator">=</span><span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//even if all the parameters of a template's typename parameter list is default argued</span>
<span class="token comment">//we have to use angle brackets to ask compiler instantiate a class from a template</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">tmp_array</span><span class="token punctuation">&#123;</span><span class="token comment">/*details*/</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
tmp_array<span class="token operator">&lt;</span><span class="token operator">></span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Besides, it is known that once we define a template class’ type, compiler instantiates a class instance. But this activity faces an embarrassing situation. Once we create a project and use template class with the same type in different file, the compiler will instantiates several instances in each file. Which may be a mass overhead. We can use the key word <strong>extern</strong> to declare a class to prevent from such overhead.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">Blob</span><span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">;</span>				<span class="token comment">//declaration</span>
<span class="token keyword">template</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//definition</span>
												<span class="token comment">//in this case, compiler will instantiates the whole members</span>
												<span class="token comment">//thus the type must apply to every member</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	Blob<span class="token operator">&lt;</span>string<span class="token operator">></span> sa1<span class="token punctuation">,</span> sa2<span class="token punctuation">;</span> <span class="token comment">//compiler instantiates class in other file</span>
					    <span class="token comment">//Thus key word extern expresses that there is a definition in our project</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>and if we can’t make sure what the return type definitely is, we can use the tail-set return to declare function’s return type</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//using tail-set return to explicitly declare function's return type</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">It</span><span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">fcn</span><span class="token punctuation">(</span>It beg<span class="token punctuation">,</span> It end<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">//details</span>
	<span class="token keyword">return</span> <span class="token operator">*</span>beg<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="reference-collapsing">reference collapsing:</h3>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>X&amp; &amp;, X&amp; &amp;&amp;, X&amp;&amp; &amp; will collapse to X&amp;</p>
<p>X&amp;&amp; &amp;&amp; will be collapse to X&amp;&amp;</p></blockquote>
<p>By define a parameter as an rvalue reference, we can save all of argument’s type-info. By using reference, we can save the const-info. By define parameters as rvalue references, we can use reference collapsing to save arguments’ reference characteristic.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">flip</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1 <span class="token operator">&amp;&amp;</span>t1<span class="token punctuation">,</span> T2 <span class="token operator">&amp;&amp;</span>t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">f</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>However, function expression returns an lvalue, which restrict us from binding an rvalue reference to an rvalue reference. In this case, we need to use the lib function <strong>std::forward</strong>, which is defined in lib <em>utility</em>, to save the reference type(by using the reference collapsing). Thus, we modifies the original code to the below one</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">flip</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> T1 <span class="token operator">&amp;&amp;</span>t1<span class="token punctuation">,</span> T2 <span class="token operator">&amp;&amp;</span>t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1<span class="token operator">></span></span></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2<span class="token operator">></span></span></span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>When we overload a template function, compiler will chose the more specialized one. Thus if we define a template function</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> string <span class="token function">func</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/*details*/</span><span class="token punctuation">&#125;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> string <span class="token function">func</span><span class="token punctuation">(</span>T <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/*details*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>and we hope the compiler may cope with <em>char</em> &amp; <em>const char</em> as <em>string</em>, we need to define two specialized overloaded function</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//declare a string type instance to avoid from default call </span>
string <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
string <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="parameter-packet">parameter packet</h3>
<p>we use symbol <strong>…</strong> after keyword <em>typename</em> or <em>class</em> to express indefinite number of parameters</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Args is a template parameter packet, rest is a function parameter packet</span>
<span class="token comment">//Args means zero or several template parameters</span>
<span class="token comment">//rest means zero or several function parameters</span>
<span class="token comment">//types in packet can be different from each other</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    cout<span class="token operator">&lt;&lt;</span>T<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> rest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>we can use <strong>sizeof</strong> to calculate the number of parameters in the packet</p>
<p><strong>call packet parameters</strong>:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//end the recursion and print the last element</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//recursion call</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	os <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>
	string s <span class="token operator">=</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> i<span class="token punctuation">,</span> d<span class="token punctuation">,</span> l<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//output:1       2       321     hello world!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="specialize">specialize</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//specialize</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span> size_t M<span class="token operator">></span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//const char(&amp;)[M] is a reference to an char array</span>

<span class="token comment">//a specialized instance of function compare</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">></span>
<span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a reference to an const (or not) pointer</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>notice</strong>: Once we need a specialized instance but forget to declare or define one, where there is a template suits to this instance’s type, the compiler will instantiate an instance. This mistake won’t be checked up. Thus we are supposed to define templates with the same name in the same header file. And put the specialized instances after those template. Certainly we need to check up whether we have declared an instance or not.</p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>//post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1>欠拟合与过拟合</h1>
<p>在机器学习过程中，我们将学习器的实际输出<img src="https://math.now.sh?inline=f%28x%3BD%29" style="display:inline-block;margin: 0;"> (<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;">为训练集）与样本的真实输出 <img src="https://math.now.sh?inline=y_%7BD%7D" style="display:inline-block;margin: 0;">之间的差异称为“误差”。<br>
我们称学习器在训练集上的误差称之为“训练误差”(training error)或“经验误差”(empirical error)，在新样本上的误差称为“泛化误差”(generalization error)。<br>
大部分情况下，我们可以获得一个在训练集上表现很好，经验误差非常小的学习器。然而，当一个学习器对训练集拟合程度非常好时，往往意味着它学习了训练集中那些并不普遍的规律。因而在面对新样本时产生了错判，导致学习器的泛化能力下降。这种现象在机器学习中被成为“过拟合”(overfitting)现象。与之相对的是“欠拟合”(underfitting)现象，即学习器未能很好地学习样本的普遍规律。<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1632911339/watermark_scdyry.jpg" alt="过拟合与欠拟合现象"><br>
我们训练学习器的目的是为了获取泛化能力较好的模型。然而，我们无法直接获得泛化误差，而对训练集的误差评估又存在过拟合等问题。因此，我们需要讨论针对模型的评估方法，以获取表现较好的模型。</p>
<h1>评估方法</h1>
<p>为了评估模型的泛化能力，我们将数据集<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;">进行适当的处理，分为训练集<img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;">(training set)和测试集<img src="https://math.now.sh?inline=T" style="display:inline-block;margin: 0;">(testing set)。接下来讨论几种常见的划分数据集的方法。</p>
<h2 id="留出法">留出法</h2>
<p>“留出法”(hold-out)将数据集<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;">划分为两个互斥的集合。其中一个作为训练集<img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;">，另一个作为测试集<img src="https://math.now.sh?inline=T" style="display:inline-block;margin: 0;">。即<img src="https://math.now.sh?inline=S%5Ccup%20T%20%3D%20D" style="display:inline-block;margin: 0;">且<img src="https://math.now.sh?inline=S%20%5Ccap%20T%20%3D%20%20%5Cvarnothing" style="display:inline-block;margin: 0;">。<br>
需要注意的是，在划分数据集时需要尽可能保持数据分布的一致性，避免在数据划分过程中引入额外的偏差。一般采用“分层采样”(stratified sampling)的方式划分数据集。<br>
为了避免单次留出法估计结果的偶然误差，一般采用若干次随机划分、重复进行实验评估后取平均值作为最终结果。<br>
在划分数据集时，我们希望训练集<img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;">足够大以更接近<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;">的普遍规律；也希望测试集<img src="https://math.now.sh?inline=T" style="display:inline-block;margin: 0;">足够大以避免偶然误差。一般采取2/3 ~ 4/5的样本用于训练集，剩余的用于测试集。</p>
<h2 id="交叉验证法">交叉验证法</h2>
<p>“交叉验证法”(cross validation)将数据集划分为<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;">个大小相近的互斥子集 <img src="https://math.now.sh?inline=D_%7B1%7D%2CD_%7B2%7D%2C...%2CD_%7Bk%7D" style="display:inline-block;margin: 0;"> 。有<img src="https://math.now.sh?inline=D%20%3D%20D_%7B1%7D%20%5Ccup%20%20D_%7B2%7D%20%5Ccup%20...%5Ccup%20D_%7Bk%7D%2C%20D_%7Bi%7D%20%5Ccap%20D_%7Bj%7D%20%3D%20%5Cvarnothing%20%28i%20%5Cneq%20j%29" style="display:inline-block;margin: 0;">。每次取<img src="https://math.now.sh?inline=k-1" style="display:inline-block;margin: 0;">个子集用于训练集，余下的子集用于测试集。最终返回这<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;">个测试结果的平均值。<br>
交叉验证法评估结果的稳定性和保真性很大程度上取决于<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;">的取值，所以也称交叉验证法为“<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;">折交叉验证”(k-fold cross validation)。<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;">最常用的取值为10；也经常取值为5、20等。<br>
当每次评估只取一个样本作为测试集时，则得到交叉验证法的一个特例：留一法(Leave-One-Out， 简称LOO)。由于留一法的测试集与数据集<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;">只差一个样本，所以留一法的评估结果往往被认为比较准确。然而，当数据集比较大时，训练模型的计算开销可能难以承受。</p>
<h2 id="自助法">自助法</h2>
<p>当我们难以对数据集进行有效划分且无法承担留一法的巨大计算开销时，可以采用“自助法”(bootstrapping)。对于给定数据集 <img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"> ，对其进行<img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;">次有放回的抽样，获得包含<img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;">个（可能出现重复样本的）数据集 <img src="https://math.now.sh?inline=D'" style="display:inline-block;margin: 0;"> 。<br>
可以计算某样本在m次抽样中始终不被抽到的概率为<img src="https://math.now.sh?inline=%281%20-%20%5Cfrac%7B1%7D%7Bm%7D%29%5E%7Bm%7D" style="display:inline-block;margin: 0;">。取极限得<br>
<img src="https://math.now.sh?inline=%5Clim_%7Bx%5Crightarrow%20%5Cinfty%20%7D%281%20-%20%5Cfrac%7B1%7D%7Bm%7D%29%5E%7Bm%7D." style="display:inline-block;margin: 0;"><br>
而实际中 <img src="https://math.now.sh?inline=D%5Csetminus%20D'" style="display:inline-block;margin: 0;"> 的样本数期望为<img src="https://math.now.sh?inline=m%281%20-%20%5Cfrac%7B1%7D%7Bm%7D%29%5E%7Bm%7D" style="display:inline-block;margin: 0;">。取 <img src="https://math.now.sh?inline=D'" style="display:inline-block;margin: 0;"> 为训练集，<img src="https://math.now.sh?inline=D%5Csetminus%20D'" style="display:inline-block;margin: 0;"> 为测试集。这样，实际评估的模型与期望评估的模型都使用 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"> 个训练样本，而我们仍然有占样本总数约1/3的未出现在训练集中的样本用于测试。这种测试结果，亦称“包外估计”(out-of-bag estimate)。<br>
自助法在数据集较小、难以有效划分训练集/测试集时很有用。此外，自助法可以产生多个不同的训练集，这对集成学习等方法有很大的好处。然而，自助法改变了数据集的分布，会引入估计偏差。因此，当初始数据量足够时，留出法和交叉验证法更常用一些。</p>
<h2 id="调参与最终模型">调参与最终模型</h2>
<p>大多数学习算法都有参数。这些参数的设置对于模型的效果有着非常显著的影响。因此，除了对适用的学习算法进行选择外，还需要对算法参数进行设定。一般对于实数范围内取值的参数，常常采用选定范围和变化步长的方式来进行调参。<br>
在建立模型过程中，我们将数据集 <img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"> 划分为训练集与测试集，即每次只采用了一部分数据训练模型。在模型选择完成后，学习算法与参数配置已经选定。此时应该用数据集 <img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"> 重新训练模型并提交给用户。<br>
在之前的评估方法介绍中，我们将数据集划分为训练数据与测试集。并用测试数据来估计模型在实际使用时的泛化能力。因此，我们需要将训练数据划分为训练集与验证集(validation set)，基于验证集上的性能来进行模型选择和调参。（可以根据划分训练数据/测试数据的方法来划分训练集/验证集）。</p>
<table>
    <tr>
        <td colspan="3">数据集</td> 
   </tr>
    <tr>
      	 <td colspan="2">训练数据</td> 
      	 <td>测试数据</td>   
    </tr>
    <tr>
        <td>训练集</td>
         <td>验证集</td>
         <td>测试集</td>    
    </tr>
</table>
<h1>性能度量</h1>
<p>为了评估学习器的泛化性能，除了有效可行的实验估计方法，还需要衡量模型泛化能力的评价标准，即性能度量(performance measure)。<br>
在预测任务中，给定样例集<img src="https://math.now.sh?inline=D%20%3D%20%5Cleft%20%5C%7B%20%28x_%7B1%7D%2Cy_%7B1%7D%29%2C(x_%7B2%7D%2Cy_%7B2%7D)%2C...%2C(x_%7Bm%7D%2Cy_%7Bm%7D)%20%5Cright%20%5C%7D" style="display:inline-block;margin: 0;">,学习器的预测结果为<img src="https://math.now.sh?inline=f%28x%29" style="display:inline-block;margin: 0;">。在回归模型中，最常用的性能度量为“均方误差”(mean squared error)</p>
<p style><img src="https://math.now.sh?from=E%28f%3BD%29%20%3D%20%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D(f(x_%7Bi%7D)%20-%20y_%7Bi%7D)%5E%7B2%7D.%0A"></p><p>对于数据分布<img src="https://math.now.sh?inline=%5Cmathfrak%7BD%7D" style="display:inline-block;margin: 0;">和概率密度函数<img src="https://math.now.sh?inline=p%28.%29" style="display:inline-block;margin: 0;">，均方误差可描述为</p>
<p style><img src="https://math.now.sh?from=E%28f%3B%5Cmathfrak%7BD%7D%29%20%3D%20%5Cint_%7Bx%5Csim%20%5Cmathfrak%7BD%7D%7D(f(x)%20-%20y)%5E%7B2%7Dp(x)dx.%0A"></p><p>接下来将介绍分类任务中常用的性能度量</p>
<h2 id="错误率与精度">错误率与精度</h2>
<p>对于样例集<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;">，分类错误率定义为</p>
<p style><img src="https://math.now.sh?from=E%28f%3BD%29%20%3D%20%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cmathbb%7BI%7D(f(x_%7Bi%7D%20%5Cneq%20y_%7Bi%7D).%0A"></p><p>精度定义为</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Aacc%28f%3BD%29%20%26%3D%20%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cmathbb%7BI%7D(f(x_%7Bi%7D%20%3D%20y_%7Bi%7D)%20%5C%5C%20%0A%26%3D%201%20-%20E(f%3BD)%0A%5Cend%7Baligned%7D%0A"></p><p>更一般地，对于数据分布<img src="https://math.now.sh?inline=%5Cmathfrak%7BD%7D" style="display:inline-block;margin: 0;">和概率密度函数<img src="https://math.now.sh?inline=p%28.%29" style="display:inline-block;margin: 0;">，错误率和精度为</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28f%3B%5Cmathfrak%7BD%7D%29%20%26%3D%20%5Cint_%7Bx%5Csim%20%5Cmathfrak%7BD%7D%7D%5Cmathbb%7BI%7D(f(x)%5Cneq%20y)p(x)dx%2C%5C%5C%0Aacc(f%3B%5Cmathfrak%7BD%7D)%20%26%3D%20%5Cint_%7Bx%5Csim%20%5Cmathfrak%7BD%7D%7D%5Cmathbb%7BI%7D(f(x)%20%3D%20%20y)p(x)dx.%0A%5Cend%7Baligned%7D%0A"></p><h2 id="查准率与查全率">查准率与查全率</h2>
<p>查准率(precision)用于衡量“检索出的信息中用户感兴趣的比例”<br>
查全率(recall)用于衡量“用户感兴趣的信息被检索出来的比例”<br>
考虑一个二分类的问题。假设用户感兴趣的信息为正例。因此，我们的学习器应当检索并向用户推荐正例。对于学习器而言，其预测结果可分为以下四类：</p>
<center><font face="楷体">分类结果的混淆矩阵</font></center>
<table>
    <tr>
    	<td rowspan="2">真实情况</td>
        <td colspan="2">预测结果</td> 
   </tr>
    <tr>
      	 <td>正例</td> 
      	 <td>反例</td>   
    </tr>
    <tr>
        <td>正例</td>
         <td>TP(真正例)</td>
         <td>FN(假反例)</td>    
    </tr>
    <tr>
        <td>反例</td>
         <td>FP(假正例)</td>
         <td>TN(真反例)</td>    
    </tr>    
</table>
<p>则查准率P与查全率R的定义为：</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%20%26%3D%20%5Cfrac%7BTP%7D%7BTP%20%2B%20FP%7D%2C%5C%5C%0AR%20%26%3D%20%5Cfrac%7BTP%7D%7BTP%20%2B%20FN%7D.%0A%5Cend%7Baligned%7D%0A"></p><p>查准率和查全率是一对矛盾的度量。当我们将所有的样本选中，则所有用户感兴趣的样本也都被选中了，但这样查准率就比较低。而若是只挑选那些非常有把握的样本，查准率会较高，然而选中的样本占用户感兴趣的样本总量的比例就会降低，查全率也低了。<br>
通常，我们可以根据学习器的预测结果（比方说预测用户感兴趣的概率大小）按照由高到低的顺序进行排序。按此顺序逐个将样本作为正例进行预测。（比方说逐次将某个概率以上的样本预测为正例），并计算出当前的查全率、查准率。以查准率为纵轴，查全率为横轴作图，就得到查准率-查全率曲线，简称“P-R曲线”。并取查准率=查重率的点为平衡点。<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1632911339/watermark_type_ZmFuZ3poZW5naGV_texxd5.png" alt="P-R曲线与平衡点示意图"></p>
<h2 id="查准率-查全率的性能度量">查准率、查全率的性能度量</h2>
<p>综合考率学习器查准率、查全率的性能度量有</p>
<ul>
<li>“平衡点”(break-Even Point， 简称BEP)。</li>
</ul>
<p>为查准率=查全率时的取值。若学习器A的BEP高于学习器B的，则认可学习器A优于学习器B。</p>
<ul>
<li><img src="https://math.now.sh?inline=F_%7B1%7D" style="display:inline-block;margin: 0;">度量</li>
</ul>
<p><img src="https://math.now.sh?inline=F_%7B1%7D" style="display:inline-block;margin: 0;">度量基于查准率与查全率的调和平均(harmony mean)定义的。<img src="https://math.now.sh?inline=F_%7B1%7D" style="display:inline-block;margin: 0;">的取值范围为[0,1]，它的大小衡量了模型的稳定性，数值越大，说明模型的稳定性越好。</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B1%7D%7BF_%7B1%7D%7D%20%26%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Ccdot%20%5Cleft%28%5Cfrac%7B1%7D%7BP%7D%20%2B%20%5Cfrac%7B1%7D%7BR%7D%20%5Cright%29%5C%5C%0A%20%20%20%20F_%7B1%7D%20%26%3D%20%5Cfrac%7B2%20%5Ctimes%20P%20%5Ctimes%20R%7D%7BP%20%2B%20R%7D%20%3D%20%5Cfrac%7B2%20%5Ctimes%20TP%7D%7B%E6%A0%B7%E4%BE%8B%E6%80%BB%E6%95%B0%20%2B%20TP%20-%20TN%7D%0A%5Cend%7Baligned%7D%0A"></p><ul>
<li><img src="https://math.now.sh?inline=F_%7B%5Cbeta%7D" style="display:inline-block;margin: 0;">度量<br>
当我们对查全率和查准率的重视程度有所不同时，我们采用<img src="https://math.now.sh?inline=F_%7B%5Cbeta%7D" style="display:inline-block;margin: 0;">表达对查全率/查准率的偏好</li>
</ul>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B1%7D%7BF_%7B%5Cbeta%7D%7D%20%26%3D%20%5Cfrac%7B1%7D%7B1%20%2B%20%5Cbeta%5E%7B2%7D%7D%20%5Ccdot%20%5Cleft%28%5Cfrac%7B1%7D%7BP%7D%20%2B%20%5Cfrac%7B%5Cbeta%5E%7B2%7D%7D%7BR%7D%5Cright%29%5C%5C%0A%20%20%20%20F_%7B%5Cbeta%7D%20%26%3D%20%5Cfrac%7B(1%2B%5Cbeta%5E%7B2%7D)%20%5Ctimes%20P%20%5Ctimes%20R%7D%7B(%5Cbeta%5E%7B2%7D%20%5Ctimes%20P)%20%2B%20R%7D%0A%5Cend%7Baligned%7D%0A"></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>其中<img src="https://math.now.sh?inline=%5Cbeta%20%3E%200" style="display:inline-block;margin: 0;">度量了查全率对查准率的相对重要性。 <img src="https://math.now.sh?inline=%5Cbeta%3E1" style="display:inline-block;margin: 0;">时查全率有更大影响，<img src="https://math.now.sh?inline=%5Cbeta%3C1" style="display:inline-block;margin: 0;">时查准率有更大影响。</p></blockquote>
<p>与算术平均<img src="https://math.now.sh?inline=%5Cleft%28%20%5Cfrac%7BP%2BR%7D%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;">和几何平均<img src="https://math.now.sh?inline=%28%5Csqrt%7BP%20%5Ctimes%20R%7D%29" style="display:inline-block;margin: 0;">相比，调和平均更重视较小值。</p>
<p>当我们有多个二分类混淆矩阵时，可以有如下思路综合考察查准率与查重率</p>
<ol>
<li>先计算各混淆矩阵的查准率与查全率，再综合计算<br>
计算各混淆矩阵的查准率和查全率<img src="https://math.now.sh?inline=%28P_%7B1%7D%2CR_%7B1%7D%29%2C(P_%7B2%7D%2C%20R_%7B2%7D)%2C...%2C(P_%7Bn%7D%2CR_%7Bn%7D)" style="display:inline-block;margin: 0;">，再计算平均值。得到“宏查准率”(macro-P)、“宏查全率”(macro-R)、“宏<img src="https://math.now.sh?inline=F_%7B1%7D" style="display:inline-block;margin: 0;">”(macro-<img src="https://math.now.sh?inline=F_%7B1%7D" style="display:inline-block;margin: 0;">):</li>
</ol>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26macro%5C!-%5C!%5C!P%20%3D%20%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7DP_%7Bi%7D%2C%5C%5C%0A%26macro%5C!-%5C!%5C!R%20%3D%20%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7DR_%7Bi%7D%2C%5C%5C%0A%26macro%5C!-%5C!%5C!F_%7B1%7D%20%3D%20%5Cfrac%7B2%20%5Ctimes%20macro%5C!-%5C!%5C!P%20%5Ctimes%20macro%5C!-%5C!%5C!R%7D%7Bmacro%5C!-%5C!%5C!P%20%2B%20macro%5C!-%5C!%5C!R%7D.%0A%5Cend%7Baligned%7D%0A"></p><ol start="2">
<li>先对各混淆矩阵的对应元素进行平均，再基于平均值计算<br>
计算出各元素的平均值<img src="https://math.now.sh?inline=%5Coverline%7BTP%7D%E3%80%81%5Coverline%7BFP%7D%E3%80%81%5Coverline%7BTN%7D%E3%80%81%5Coverline%7BFN%7D" style="display:inline-block;margin: 0;">，再基于这些平均值计算出“微查准率”(micro-P)、“微查全率”(micro-R)和“微<img src="https://math.now.sh?inline=F_%7B1%7D" style="display:inline-block;margin: 0;">”(micro-<img src="https://math.now.sh?inline=F_%7B1%7D" style="display:inline-block;margin: 0;">)：</li>
</ol>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26micro%5C!-%5C!%5C!P%20%3D%20%5Cfrac%7B%5Coverline%7BTP%7D%7D%7B%5Coverline%7BTP%7D%20%2B%20%5Coverline%7BFP%7D%7D%2C%5C%5C%0A%26micro%5C!-%5C!%5C!R%20%3D%20%5Cfrac%7B%5Coverline%7BTP%7D%7D%7B%5Coverline%7BTP%7D%20%2B%20%5Coverline%7BFN%7D%7D%2C%5C%5C%0A%26micro%5C!-%5C!%5C!F_%7B1%7D%20%3D%20%5Cfrac%7B2%20%5Ctimes%20micro%5C!-%5C!%5C!P%20%5Ctimes%20mairo%5C!-%5C!%5C!R%7D%7Bmicro%5C!-%5C!%5C!P%20%2B%20micro%5C!-%5C!%5C!R%7D.%5C%5C%0A%5Cend%7Baligned%7D%0A"></p><h2 id="roc与auc">ROC与AUC</h2>
<p>通常，我们根据学习器的预测结果（比方说预测用户感兴趣的概率大小）按照由高到低的顺序进行排序。并在这个排序中选取一个“截断点”(cut point)将1样本分为两部分。前一部分判定为正例，后一部分判定为反例。<br>
我们可以根据任务需求来采用不同截断点。若我们更重视“查准率”，则可以选择排序靠前的位置进行截断。反之则选择排序靠后的。因此，排序质量的好坏体现了学习器在“一般情况下”泛化性能的好坏。ROC(Receiver Operating Characteristic， “受试者工作特征”)曲线就是从排序质量的角度出发研究学习器泛化性能的工具。<br>
ROC曲线根据学习器的预测结果进行排序，并逐个把样本作为正例进行预测。每次计算“真正利率”(True Positive Rate, TPR)与“假正例率”(False Positive Rate, FPR)</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26T%5C!P%5C!R%20%3D%20%5Cfrac%7BTP%7D%7BTP%20%2B%20FN%7D%5C%5C%0A%26F%5C!P%5C!R%20%3D%20%5Cfrac%7BFP%7D%7BTN%20%2B%20FP%7D%0A%5Cend%7Baligned%7D%0A"></p><p>以TPR值为纵轴，FPR值为横轴，作出POC曲线<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1632911338/watermark1_gtltmk.png" alt="在这里插入图片描述"><br>
显然，此图中对角线对应“随即猜测”模型，而点（0，1）对应于将所有正例排在所有反例之前的“理想模型”。<br>
现实中我们使用有限个测试样例绘制POC图。若给定<img src="https://math.now.sh?inline=m%5E%7B%2B%7D" style="display:inline-block;margin: 0;">个正例和<img src="https://math.now.sh?inline=m%5E%7B-%7D" style="display:inline-block;margin: 0;">个反例，根据学习器预测值进行排序。先将分类阈值设为最大，此时TPR和FPR都为0（TP和FP为0），在坐标(0,0)处标记一个点。随后依次将分类阈值设为每个样例的预测值，使其判断为正例。设前一个标记点坐标为<img src="https://math.now.sh?inline=%28x%2Cy%29" style="display:inline-block;margin: 0;">，若当前为真正例，则对应标记点坐标为<img src="https://math.now.sh?inline=%28x%2Cy%2B%5Cfrac%7B1%7D%7Bm%5E%7B%2B%7D%7D%29" style="display:inline-block;margin: 0;">；反之为<img src="https://math.now.sh?inline=%28x%20%2B%20%5Cfrac%7B1%7D%7Bm%5E%7B-%7D%7D%2C%20y%29" style="display:inline-block;margin: 0;">。然后用线段连接相邻点。效果如下图<br>
<img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1632911339/watermark_type_ZmFuZ3poZW5naGV_2_zk1dyx.png" alt="在这里插入图片描述"></p>
<p>衡量学习器泛化能力的一个比较合理的判据是POC曲线下的面积，即AUC(Area Under POC Curve)。若设POC曲线由坐标为<img src="https://math.now.sh?inline=%5Cleft%5C%7B%20%28x_%7B1%7D%2Cy_%7B1%7D%29%2C(x_%7B2%7D%2Cy_%7B2%7D)%2C...%2C(x_%7Bn%7D%2Cy_%7Bn%7D)%20%5Cright%5C%7D" style="display:inline-block;margin: 0;">的点按序连接而成，则有</p>
<p style><img src="https://math.now.sh?from=AU%5C!C%20%3D%20%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7Bm-1%7D%28x_%7Bi%2B1%7D-x_%7Bi%7D%29%5Ccdot(y_%7Bi%7D%20%2B%20y_%7Bi%2B1%7D)%0A"></p><p>由于AUC考虑的是样本预测的排序质量，因此与排序误差有较强的联系。给定<img src="https://math.now.sh?inline=m%5E%7B%2B%7D" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=m%5E%7B-%7D" style="display:inline-block;margin: 0;">个正例和反例，令<img src="https://math.now.sh?inline=D%5E%7B%2B%7D" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=D%5E%7B-%7D" style="display:inline-block;margin: 0;">表示正、反例集合，则排序“损失”(loss)定义为</p>
<p style><img src="https://math.now.sh?from=%5Ciota_%7Brank%7D%20%3D%20%5Cfrac%7B1%7D%7Bm%5E%7B%2B%7Dm%5E%7B-%7D%7D%5Csum_%7Bx%5E%7B%2B%7D%5Cin%20D%5E%7B%2B%7D%7D%5Csum_%7Bx%5E%7B-%7D%5Cin%20D%5E%7B-%7D%7D%5Cleft%28%5Cmathbb%7BI%7D(f(x%5E%7B%2B%7D%29%20%3C%20f(x%5E%7B-%7D))%20%2B%20%5Cfrac%7B1%7D%7B2%7D%5Cmathbb%7BI%7D(f(x%5E%7B%2B%7D)%20%3D%20f(x%5E%7B-%7D))%20%5Cright)%0A"></p><p>容易看出<img src="https://math.now.sh?inline=AUC%20%3D%201%20-%20%5Ciota_%7Brank%7D" style="display:inline-block;margin: 0;"></p>
<h2 id="代价敏感错误率与代价曲线">代价敏感错误率与代价曲线</h2>
<p>在现实任务中常会遇到这种情况：不同类型的错误造成的后果不同。如医院错将健康人误诊为病人，或将患者误诊为健康人。然而，这两种错误的代价并不一致。前者增加了进一步检查的麻烦，后者则可能造成患者错过治疗的最佳时期。为了权衡不同类型错误造成的损失，可以为错误赋予“非均等代价”(unequal cost)。<br>
以二分类任务为例，可以根据任务设定一个代价矩阵。其中<img src="https://math.now.sh?inline=cost_%7Bij%7D" style="display:inline-block;margin: 0;">表示将第i类样本预测为第j类样本的代价。一般来说<img src="https://math.now.sh?inline=cost_%7Bii%7D%20%3D%200" style="display:inline-block;margin: 0;">。错判的代价越大，则<img src="https://math.now.sh?inline=cost_%7Bij%7D" style="display:inline-block;margin: 0;">也越大。通过代价的比值来衡量不同错判的损失程度相差。（一般情况下，重要的是比值而非绝对值。如<img src="https://math.now.sh?inline=cost_%7B01%7D%3Acost_%7B10%7D%20%3D%205%3A1" style="display:inline-block;margin: 0;">与<img src="https://math.now.sh?inline=50%3A10" style="display:inline-block;margin: 0;">的效果相同）。</p>
<center><font face="楷体">二分类的代价矩阵</font></center>
<table>
    <tr>
    	<td rowspan="2">真实类别</td>
        <td colspan="2">预测类别</td> 
   </tr>
    <tr>
      	 <td>第0类</td> 
      	 <td>第1类</td>   
    </tr>
    <tr>
        <td>第0类</td>
         <td>0</td>
         <td>cost<sub>01</sub></td>    
    </tr>
    <tr>
        <td>第1类</td>
         <td>cost<sub>10</sub></td>
         <td>0</td>    
    </tr>    
</table>
<p>在非均等条件下，我们希望最小化“总体代价”(total cost)。若将第0类作为正例，第1类作为反例。令<img src="https://math.now.sh?inline=D%5E%7B%2B%7D" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=D%5E%7B-%7D" style="display:inline-block;margin: 0;">作为正例子集和反例子集，则“代价敏感”(cost-sensitive)错误率为</p>
<p style><img src="https://math.now.sh?from=E%28f%3BD%3Bcost%29%20%3D%20%5Cfrac%7B1%7D%7Bm%7D%5Cleft(%5Csum_%7Bx_%7Bi%7D%20%5Cin%20D%5E%7B%2B%7D%7D%5Cmathbb%7BI%7D(f(x_%7Bi%7D)%20%5Cneq%20y_%7Bi%7D)%20%5Ctimes%20cost_%7B01%7D%20%2B%20%5Csum_%7Bx_%7Bi%7D%20%5Cin%20D%5E%7B-%7D%7D%20%5Cmathbb%7BI%7D(f(x_%7Bi%7D)%20%5Cneq%20y_%7Bi%7D)%20%5Ctimes%20cost_%7B10%7D%20%5Cright).%0A"></p><p>也可类似地定义多任务的代价敏感性能度量。<br>
在非均等条件下，我们通过“代价曲线”(cost curve)反映学习器的期望总体代价。代价曲线图的横轴为取值为[0,1]的正例概率代价：</p>
<p style><img src="https://math.now.sh?from=P%28%2B%29cost%20%3D%20%5Cfrac%7Bp%20%5Ctimes%20cost_%7B01%7D%7D%7Bp%20%5Ctimes%20cost_%7B01%7D%20%2B%20(1%20-%20p)%20%5Ctimes%20cost_%7B10%7D%7D%0A"></p><p>其中<img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;">是样例为正例的概率，纵轴是取值为[0,1]的正例概率代价。则归一化代价为</p>
<p style><img src="https://math.now.sh?from=cost_%7Bnorm%7D%20%3D%20%5Cfrac%7BF%5C!N%5C!R%20%5Ctimes%20p%20%5Ctimes%20cost_%7B01%7D%20%2B%20F%5C!P%5C!R%20%5Ctimes%20%281-p%29%20%5Ctimes%20cost_%7B10%7D%7D%7Bp%20%5Ctimes%20cost_%7B01%7D%20%2B%20(1-p)%20%5Ctimes%20cost_%7B10%7D%7D%0A"></p><p>其中<img src="https://math.now.sh?inline=F%5C!P%5C!R" style="display:inline-block;margin: 0;">为假正例率，<img src="https://math.now.sh?inline=F%5C!N%5C!R%3D1-F%5C!P%5C!R" style="display:inline-block;margin: 0;">为假反例率。<img src="https://math.now.sh?inline=cost_%7Bnorm%7D" style="display:inline-block;margin: 0;">曲线下围成的面积即为学习器的期望总体代价。</p>
<h1>比较检验</h1>
<p>对于学习器之间的比较而言，我们希望比较其泛化性能，然而通过实验评估的方法我们获得的是测试集上的性能。二者的比对结果可能未必相同。<br>
这种情况下，统计假设检验(hypothesis test)为我们进行学习器性能比较提供了重要依据。为了便于讨论，采取错误率为性能度量，用<img src="https://math.now.sh?inline=%5Cepsilon" style="display:inline-block;margin: 0;">表示。</p>
<h2 id="假设检验">假设检验</h2>
<p>在现实任务中，我们无法直接获知学习器的泛化错误率，只能获知其测试错误率<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D" style="display:inline-block;margin: 0;">。对于一个学习器而言，泛化错误率表示学习器在一个样本上犯错的概率为<img src="https://math.now.sh?inline=%5Cepsilon" style="display:inline-block;margin: 0;">，测试错误率<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D" style="display:inline-block;margin: 0;">表示在<img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;">个样本中恰有<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D%20%5Ctimes%20m" style="display:inline-block;margin: 0;">个被误分类。假定测试样本是从样本总体分布中独立采样而得，则泛化错误率为<img src="https://math.now.sh?inline=%5Cepsilon" style="display:inline-block;margin: 0;">的学习器将其中<img src="https://math.now.sh?inline=m'" style="display:inline-block;margin: 0;">个样本误分类、其余样本全部分类正确的概率为<img src="https://math.now.sh?inline=%5Cbinom%7Bm%7D%7Bm'%7D%5Cepsilon%5E%7Bm'%7D%281-%5Cepsilon%29%5E%7Bm%20-%20m'%7D" style="display:inline-block;margin: 0;">。则该学习器恰将<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D%20%5Ctimes%20m" style="display:inline-block;margin: 0;">个样本误分类的概率为</p>
<p style><img src="https://math.now.sh?from=P%28%5Chat%7B%5Cepsilon%7D%3B%5Cepsilon%29%3D%5Cbinom%7Bm%7D%7B%5Chat%7B%5Cepsilon%7D%20%5Ctimes%20m%7D%5Cepsilon%5E%7B%5Chat%7B%5Cepsilon%7D%20%5Ctimes%20m%7D(1%20-%20%5Cepsilon)%5E%7Bm%20-%20%5Chat%7B%5Cepsilon%7D%20%5Ctimes%20m%7D%0A"></p><p>对于给定<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D" style="display:inline-block;margin: 0;">，可解<img src="https://math.now.sh?inline=%5Cpartial%20P%28%5Chat%7B%5Cepsilon%7D%3B%5Cepsilon%29%2F%5Cpartial%20%5Cepsilon%20%3D%200" style="display:inline-block;margin: 0;">可得<img src="https://math.now.sh?inline=P%28%5Chat%7B%5Cepsilon%7D%3B%5Cepsilon%29" style="display:inline-block;margin: 0;">在<img src="https://math.now.sh?inline=%5Cepsilon%20%3D%20%5Chat%7B%5Cepsilon%7D" style="display:inline-block;margin: 0;">处取得最大值，符合二项分布。那么对于泛化错误率，我们考虑假设<img src="https://math.now.sh?inline=%E2%80%9C%5Cepsilon%20%5Cleq%20%5Cepsilon_%7B0%7D%E2%80%9D" style="display:inline-block;margin: 0;">，则在<img src="https://math.now.sh?inline=1%20-%20%5Calpha" style="display:inline-block;margin: 0;">的概率内能观测到的最大错误率为</p>
<p style><img src="https://math.now.sh?from=%5Cbar%7B%5Cepsilon%7D%20%3D%20min%20%5C%3B%20%5Cepsilon%20%5Cquad%20s.t.%20%5Cquad%20%5Csum_%7Bi%20%3D%20%5Cepsilon_%7B0%7D%5Ctimes%20m%20%2B%201%7D%5E%7Bm%7D%20%5Cbinom%7Bm%7D%7Bi%7D%5Cepsilon%5E%7Bi%7D%281-%5Cepsilon%29%5E%7Bm-i%7D%20%3C%20%5Calpha%0A"></p><p>此处的<img src="https://math.now.sh?inline=1-%5Calpha" style="display:inline-block;margin: 0;">反映了结论的“置信度”(confidence)。此时若测试错误率<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D" style="display:inline-block;margin: 0;">小于临界值<img src="https://math.now.sh?inline=%5Cbar%7B%5Cepsilon%7D" style="display:inline-block;margin: 0;">，则根据二项检验可以得出结论：在<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;">的显著度下，假设<img src="https://math.now.sh?inline=%E2%80%9C%5Cepsilon%20%5Cleq%20%5Cepsilon_%7B0%7D%E2%80%9D" style="display:inline-block;margin: 0;">不能被拒绝，则能以<img src="https://math.now.sh?inline=1-%5Calpha" style="display:inline-block;margin: 0;">的置信度认为，学习器泛化错误率不大于<img src="https://math.now.sh?inline=%5Cepsilon_%7B0%7D" style="display:inline-block;margin: 0;">；否则该假设可被拒绝，即在<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;">的显著度下认为学习器的泛化错误率大于<img src="https://math.now.sh?inline=%5Cepsilon_%7B0%7D" style="display:inline-block;margin: 0;">。<br>
对于多次训练/测试得到的多个错误率<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D_%7B1%7D%2C%5Chat%7B%5Cepsilon%7D_%7B2%7D%2C...%2C%5Chat%7B%5Cepsilon%7D_%7Bn%7D" style="display:inline-block;margin: 0;">，可以使用”t检验“(t-test)。可以得到平均测试错误率<img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;">和方差<img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;">为</p>
<p style><img src="https://math.now.sh?from=%5Cmu%20%3D%20%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Chat%7B%5Cepsilon%7D_%7Bi%7D%2C%20%5C%5C%0A%09%5Csigma%5E%7B2%7D%20%3D%20%5Cfrac%7B1%7D%7Bn-1%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%28%5Chat%7B%5Cepsilon%7D_%7Bi%7D%20-%20%5Cmu%29%5E%7B2%7D.%0A"></p><p>考虑到这<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;">个测试错误率可以看作泛化错误率<img src="https://math.now.sh?inline=%5Cepsilon_%7B0%7D" style="display:inline-block;margin: 0;">的独立采样，则变量</p>
<p style><img src="https://math.now.sh?from=%5Ctau_%7Bt%7D%20%3D%20%5Cfrac%7B%5Csqrt%7Bk%7D%28%5Cmu%20-%20%5Cepsilon_%7B0%7D%29%7D%7B%5Csigma%7D%0A"></p><p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1632911339/watermar_aemqpc.png" alt="在这里插入图片描述"><br>
服从自由度为<img src="https://math.now.sh?inline=k-1" style="display:inline-block;margin: 0;">的<img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;">分布。此时对于假设<img src="https://math.now.sh?inline=%E2%80%9C%5Cmu%20%3D%20%5Cepsilon_%7B0%7D%E2%80%9D" style="display:inline-block;margin: 0;">和显著度<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;">，考虑双边(two-tailed)假设，这里两边阴影各有<img src="https://math.now.sh?inline=%5Calpha%2F2" style="display:inline-block;margin: 0;">的面积；若令阴影部分分别为<img src="https://math.now.sh?inline=%28-%5Cinfty%2Ct_%7B-%5Calpha%2F2%7D%5D%2C%5Bt_%7B%5Calpha%2F2%7D%2C%5Cinfty%29" style="display:inline-block;margin: 0;">，则<img src="https://math.now.sh?inline=%5Ctau_%7Bt%7D" style="display:inline-block;margin: 0;">位于临界范围<img src="https://math.now.sh?inline=%5Bt_%7B-%5Calpha%2F2%7D%2Ct_%7B%5Calpha%2F2%7D%5D" style="display:inline-block;margin: 0;">内，则不能拒绝假设。下表为一些常用临界值。</p>
<center><font face="楷体">双边t检验的常用临界值</font></center>
<table>
    <tr>
    	<td rowspan="2">&alpha;</td>
        <td colspan="5">k</td> 
   </tr>
    <tr>
      	 <td>2</td> 
      	 <td>5</td>
      	 <td>10</td> 
      	 <td>20</td> 
      	 <td>30</td>    
    </tr>
    <tr>
        <td>0.05</td>
        <td>12.706</td> 
      	 <td>2.776</td>
      	 <td>2.262</td> 
      	 <td>2.093</td> 
      	 <td>2.045</td>    
    </tr>
    <tr>
        <td>0.10</td>
        <td>6.314</td> 
      	 <td>2.132</td>
      	 <td>1.833</td> 
      	 <td>1.729</td> 
      	 <td>1.699</td>    
    </tr>    
</table>
<h2 id="交叉验证t检验">交叉验证t检验</h2>
<p>对两个学习器A和B，我们使用k折交叉验证法得到测试错误率分别为<img src="https://math.now.sh?inline=%5Cepsilon_%7B1%7D%5E%7BA%7D%2C%5Cepsilon_%7B2%7D%5E%7BA%7D%2C...%2C%5Cepsilon_%7Bk%7D%5E%7BA%7D" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=%5Cepsilon_%7B1%7D%5E%7BB%7D%2C%5Cepsilon_%7B2%7D%5E%7BB%7D%2C...%2C%5Cepsilon_%7Bk%7D%5E%7BB%7D" style="display:inline-block;margin: 0;">。使用k折交叉验证“成对t检验”(paired t-tests)来进行比较检验。该检验的基本思想为若两个学习器相同，则它们使用相同的训练/测试集得到的测试错误率也应相同，即<img src="https://math.now.sh?inline=%5Cepsilon_%7Bi%7D%5E%7BA%7D%20%3D%20%5Cepsilon_%7Bi%7D%5E%7BB%7D" style="display:inline-block;margin: 0;">。<br>
计算方法为先对每队结果求差<img src="https://math.now.sh?inline=%5CDelta_%7Bi%7D%20%3D%20%5Cepsilon_%7Bi%7D%5E%7BA%7D%20-%20%5Cepsilon_%7Bi%7D%5E%7BB%7D" style="display:inline-block;margin: 0;">。并计算出差值的均值<img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;">和方差<img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;">，在显著度<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;">下，若变量</p>
<p style><img src="https://math.now.sh?from=%5Ctau_%7Bt%7D%20%3D%20%5Cleft%7C%20%5Cfrac%7B%5Csqrt%7Bk%7D%5Cmu%7D%7B%5Csigma%7D%20%5Cright%7C%0A"></p><p>小于临界值<img src="https://math.now.sh?inline=t_%7B%5Calpha%2F2%2Ck-1%7D" style="display:inline-block;margin: 0;">，则不拒绝假设，认为两个学习器没有显著差别。反之拒绝假设，认为平均错误率较小的学习器较优。这里的<img src="https://math.now.sh?inline=t_%7B%5Calpha%2F2%2Ck-1%7D" style="display:inline-block;margin: 0;">是自由度为<img src="https://math.now.sh?inline=k-1" style="display:inline-block;margin: 0;">的<img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;">分布上尾部积累分布为<img src="https://math.now.sh?inline=%5Calpha%2F2" style="display:inline-block;margin: 0;">的临界值。<br>
为了进行有效的假设检验，需要测试错误率均为泛化错误率的独立采样。通常情况下由于样本量有限，在使用交叉验证等实验估计方法时，不同伦茨的训练集会有一定程度的重叠，使得错误率彼此不独立，会导致高估假设成立的概率。为了缓解这一问题，可以采用“<img src="https://math.now.sh?inline=5%5Ctimes%202" style="display:inline-block;margin: 0;">交叉验证法”。<br>
<img src="https://math.now.sh?inline=5%5Ctimes%202" style="display:inline-block;margin: 0;">交叉验证法即做5次2折交叉验证，每次2折交叉验证前将随机将数据打乱，使得5次交叉验证中的数据划分不重复。对于学习器A和B，第<img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;">次2折交叉验证会产生两对测试错误率。对其分别求差得第1折和第2折的差值<img src="https://math.now.sh?inline=%5CDelta_%7Bi%7D%5E%7B1%7D%EF%BC%8C%5CDelta_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;">。为了缓解测试错误率的非独立性，仅计算第1次2折交叉验证的结果的平均值<img src="https://math.now.sh?inline=%5Cmu%20%3D%200.5%28%5CDelta_%7B1%7D%5E%7B1%7D%20%2B%20%5CDelta_%7B1%7D%5E%7B2%7D%29" style="display:inline-block;margin: 0;">，但对每次2折实验结果都计算出方差</p>
<p style><img src="https://math.now.sh?from=%5Csigma%5E%7B2%7D%20%3D%20%5Cleft%28%5CDelta_%7Bi%7D%5E%7B1%7D%20-%20%5Cfrac%7B%5CDelta_%7Bi%7D%5E%7B1%7D%20%2B%20%5CDelta_%7Bi%7D%5E%7B2%7D%7D%7B2%7D%20%5Cright%29%5E%7B2%7D%20%2B%20%5Cleft(%5CDelta_%7Bi%7D%5E%7B2%7D%20-%20%5Cfrac%7B%5CDelta_%7Bi%7D%5E%7B1%7D%20%2B%20%5CDelta_%7Bi%7D%5E%7B2%7D%7D%7B2%7D%20%5Cright)%5E%7B2%7D%20%0A"></p><p>变量</p>
<p style><img src="https://math.now.sh?from=%5Ctau_%7Bt%7D%20%3D%20%5Cfrac%7B%5Cmu%7D%7B%5Csqrt%7B0.2%5Csum_%7Bi%3D1%7D%5E%7B5%7D%5Csigma_%7Bi%7D%5E%7B2%7D%7D%7D%0A"></p><p>服从自由度为4的t分布，其双边检验的临界值<img src="https://math.now.sh?inline=t_%7B%5Calpha%2F2%2C5%7D" style="display:inline-block;margin: 0;">当<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"> = 0.05时为2.776，<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"> = 0.1时为2.132。</p>
<h2 id="mcnemar检验">McNemar检验</h2>
<p>对二分类问题，使用留出法可以列出两学习器分类结果的差别</p>
<center><font face="楷体">两学习器分类差别列联表</font></center>
<table>
    <tr>
    	<td rowspan="2">算法B</td>
        <td colspan="2">算法A</td> 
   </tr>
    <tr>
      	 <td>正确</td> 
      	 <td>错误</td>
    </tr>
    <tr>
        <td>正确</td>
        <td>e<sub>00</sub></td> 
      	 <td>e<sub>01</sub></td>    
    </tr>
    <tr>
        <td>错误</td>
        <td>e<sub>10</sub></td> 
      	 <td>e<sub>11</sub></td>    
    </tr>    
</table>
<p>若假设两学习器性能相同，应有<img src="https://math.now.sh?inline=e_%7B01%7D%20%3D%20e_%7B10%7D" style="display:inline-block;margin: 0;">，则变量<img src="https://math.now.sh?inline=%7Ce_%7B01%7D%20-%20e_%7B10%7D%7C" style="display:inline-block;margin: 0;">应当服从正态分布。McNemar检验考虑变量</p>
<p style><img src="https://math.now.sh?from=%5Ctau_%7B%5Cchi%5E%7B2%7D%7D%20%3D%20%5Cfrac%7B%28%7Ce_%7B01%7D-e_%7B10%7D%7C%20-%201%29%5E%7B2%7D%7D%7Be_%7B01%7D%20%2B%20e_%7B10%7D%7D%0A"></p><p>服从自由度为1的<img src="https://math.now.sh?inline=%5Cchi%5E%7B2%7D" style="display:inline-block;margin: 0;">分布，即标准正态分布变量的平方。对于给定显著度<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;">，当以上变量值小于临界值<img src="https://math.now.sh?inline=%5Cchi%5E%7B2%7D_%7B%5Calpha%7D" style="display:inline-block;margin: 0;">时，不能拒绝假设。否则拒绝假设，认为二者性能有显著差别，且平均错误率小的学习器性能较优。自由度为1的<img src="https://math.now.sh?inline=%5Cchi%5E%7B2%7D" style="display:inline-block;margin: 0;">检验的临界值当<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;">=0.05时为3.8415，<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;">=0.1时为2.7055。</p>
<h2 id="friedman检验与nemenyi后续检验">Friedman检验与Nemenyi后续检验</h2>
<p>当有多个算法参与比较时，我们采用基于算法排序的Friedman检验。先根据留出法或交叉验证法对每个数据集上的性能进行测试并依次排序（1、2、3…）。如果性能相同则取平均值。假定我们在<img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;">个数据集上比较<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;">个算法，令<img src="https://math.now.sh?inline=r_%7Bi%7D" style="display:inline-block;margin: 0;">表示第<img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;">个算法的平均序值，则<img src="https://math.now.sh?inline=r_%7Bi%7D" style="display:inline-block;margin: 0;">的均值和方差分别为<img src="https://math.now.sh?inline=%28k%2B1%29%2F2" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=%28k%5E%7B2%7D-1%29%2F12N" style="display:inline-block;margin: 0;">。变量</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctau_%7B%5Cchi%5E%7B2%7D%7D%20%26%3D%20%5Cfrac%7Bk-1%7D%7Bk%7D%5Ccdot%5Cfrac%7B12N%7D%7Bk%5E%7B2%7D-1%7D%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%5Cleft%28r_%7Bi%7D%20-%20%5Cfrac%7Bk%2B1%7D%7B2%7D%20%5Cright%29%5E%7B2%7D%20%5C%5C%0A%20%20%20%20%26%3D%5Cfrac%7B12N%7D%7Bk(k%2B1)%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bk%7Dr_%7Bi%7D%5E%7B2%7D-%5Cfrac%7Bk(k%2B1)%5E%7B2%7D%7D%7B4%7D%20%5Cright)%5C%5C%0A%5Ctau_%7BF%7D%20%26%3D%20%5Cfrac%7B(N-1)%5Ctau_%7B%5Cchi%5E%7B2%7D%7D%7D%7BN(k-1)%20-%20%5Ctau_%7B%5Cchi%5E%7B2%7D%7D%7D%0A%5Cend%7Baligned%7D%0A"></p><p><img src="https://math.now.sh?inline=%5Ctau_%7BF%7D" style="display:inline-block;margin: 0;">服从自由度为<img src="https://math.now.sh?inline=k-1" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=%28k-1%29(N-1)" style="display:inline-block;margin: 0;">的<img src="https://math.now.sh?inline=F" style="display:inline-block;margin: 0;">分布。<br>
若“所有算法性能相同”的假设被拒绝，则说明算法性能显著不同。此次需要“后续检验”(post-hoc test)来进一步区分各算法。如Nemenyi后续检验，其平均序值差别的临界区域为</p>
<p style><img src="https://math.now.sh?from=CD%20%3D%20q_%7B%5Calpha%7D%5Csqrt%7B%5Cfrac%7Bk%28k%2B1%29%7D%7B6N%7D%7D%0A"></p><p>若两算法的平均序值之差超过了临界值域<img src="https://math.now.sh?inline=CD" style="display:inline-block;margin: 0;">，则拒绝“两算法性能相同”的假设。</p>
<h1>偏差与方差</h1>
<p>对测试样本<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;">，令<img src="https://math.now.sh?inline=y_%7BD%7D" style="display:inline-block;margin: 0;">为<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;">在数据集中的标记，<img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;">为<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;">的真实标记，<img src="https://math.now.sh?inline=f%28x%3BD%29" style="display:inline-block;margin: 0;">为训练集<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;">上学得模型<img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;">在<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;">上的预测输出。<br>
以回归方程为例，学习算法的期望预测为</p>
<p style><img src="https://math.now.sh?from=%5Cbar%7Bf%7D%28x%29%20%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Bf(x%3BD)%5D%0A"></p><p>使用样本数相同的不同训练集产生的方差为</p>
<p style><img src="https://math.now.sh?from=var%28x%29%20%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)-%5Cbar%7Bf%7D(x)%20%5Cright)%5E%7B2%7D%20%5Cright%5D%0A"></p><p>噪声为</p>
<p style><img src="https://math.now.sh?from=%5Cvarepsilon%5E%7B2%7D%20%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%28y_%7BD%7D%20-%20y%29%5E%7B2%7D%20%5Cright%5D%0A"></p><p>期望输出与真实标记的差别称为偏差(bias)，即</p>
<p style><img src="https://math.now.sh?from=bias%5E%7B2%7D%28x%29%20%3D%20%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y%20%5Cright)%5E%7B2%7D%0A"></p><p>为了便于讨论，假定噪声期望为零，即<img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D_%7BD%7D%5By_%7BD%7D-y%5D%3D0" style="display:inline-block;margin: 0;">。通过·简单多项式展开合并，可以对算法的期望泛化误差进行分解：</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28f%3BD%29%20%26%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)%20-%20y_%7BD%7D%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%5C%5C%0A%26%20%3D%20%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)%20-%20%5Cbar%7Bf%7D(x)%20%2B%20%5Cbar%7Bf%7D(x)%20-%20y_%7BD%7D%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%5C%5C%0A%26%20%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)%20-%20%5Cbar%7Bf%7D(x)%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%2B%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y_%7BD%7D%20%5Cright)%5E%7B2%7D%20%5Cright%5D%5C%5C%0A%26%5Cquad%20%5C%3B%2B%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B2%5Cleft(f(x%3BD)%20-%20%5Cbar%7Bf%7D(x)%20%5Cright)%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y_%7BD%7D%20%5Cright)%20%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)%20-%20%5Cbar%7Bf%7D(x)%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%20%2B%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y_%7BD%7D%20%5Cright)%5E%7B2%7D%20%5Cright%5D%5C%5C%0A%26%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)%20-%20%5Cbar%7Bf%7D(x)%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%20%2B%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y%20%2B%20y%20-%20y_%7BD%7D%20%5Cright)%5E%7B2%7D%20%5Cright%5D%5C%5C%0A%26%3D%20%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)%20-%20%5Cbar%7Bf%7D(x)%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%2B%20%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%2B%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y%20%5Cright)%5E%7B2%7D%20%5Cright%5D%5C%5C%0A%26%5Cquad%20%5C%3B%20%2B%202%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y%20%5Cright)(y-y_%7BD%7D)%20%5Cright%5D%5C%5C%0A%26%3D%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(f(x%3BD)%20-%20%5Cbar%7Bf%7D(x)%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%2B%20%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(%5Cbar%7Bf%7D(x)%20-%20y%20%5Cright)%5E%7B2%7D%20%5Cright%5D%20%2B%20%5Cmathbb%7BE%7D_%7BD%7D%5Cleft%5B%5Cleft(y_%7BD%7D%20-%20y%20%5Cright)%5E%7B2%7D%20%5Cright%5D%0A%5Cend%7Baligned%7D%0A"></p><p>即</p>
<p style><img src="https://math.now.sh?from=%5Cmathbb%7BE%7D%28f%3BD%29%20%3D%20bias%5E%7B2%7D(x)%20%2B%20var(x)%20%2B%20%5Cvarepsilon%5E%7B2%7D%0A"></p><p>即泛化误差可以分解为偏差、方差与噪声之和。其中偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力。方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习任务本身的难度。<br>
一般来说，偏差和方差是有冲突的。这被称为偏差-方差窘境(bias-variance dilemma)。对于一个学习任务，在训练不足时，学习器的拟合能力不够强，训练数据的扰动不足以使学习器产生显著变化，此时偏差主导了泛化错误率。训练程度较深时，拟合能力加强，训练数据的扰动能被学习器学到，则方差开始主导了泛化错误率。若训练数据自身的、非全局的特性被学习器学到了，则会发生过拟合现象。</p>
<h1>线性回归</h1>
<p>线性模型(linear model)试图学得一个线性函数</p>
<p style><img src="https://math.now.sh?from=f%28%5Cboldsymbol%7Bx%7D%29%3Dw_%7B1%7Dx_%7B1%7D%20%2B%20w_%7B2%7Dx_%7B2%7D%20%2B...%20%2Bw_%7Bd%7Dx_%7Bd%7D%20%2B%20b%20%5Ctag%7B2%2C1%7D%20%5C%5C%0Af(%5Cboldsymbol%7Bx%7D)%20%3D%20%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%20%2B%20b%0A"></p><p>其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%20%3D%20%28w_%7B1%7D%3Bw_%7B2%7D%3B...%3Bw_%7Bd%7D%29" style="display:inline-block;margin: 0;">。<br>
线性模型虽然简单，但蕴含着机器学习中一些重要思想。许多功能强大的非线性模型(nonlinear model)可以在线性模型的基础上通过引入层级结构或高维映射而得。此外，由于<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D" style="display:inline-block;margin: 0;">直观地表达了各属性在预测中的重要性，因此线性模型有很好的解释性(comprehensibility)<br>
对给定数据集<img src="https://math.now.sh?inline=D%20%3D%20%5C%7B%28%5Cboldsymbol%7Bx%7D_%7B1%7D%2Cy_%7B1%7D%29%2C(%5Cboldsymbol%7Bx%7D_%7B2%7D%2Cy_%7B2%7D)%2C...%2C(%5Cboldsymbol%7Bx%7D_%7Bm%7D%2Cy_%7Bm%7D)%20%5C%7D" style="display:inline-block;margin: 0;">，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D_%7Bi%7D%20%3D%20%28x_%7Bi1%7D%3Bx_%7Bi2%7D%3B...%3Bx_%7Bid%7D%29%2Cy_%7Bi%7D%20%5Cin%20%5Cmathbb%7BR%7D" style="display:inline-block;margin: 0;">。先假设建立一元线性回归模型，有</p>
<p style><img src="https://math.now.sh?from=f%28x_%7Bi%7D%29%20%3D%20wx_%7Bi%7D%20%2B%20b%2Cs.t.f(x_%7Bi%7D)%5Csimeq%20y_%7Bi%7D%20%5Ctag%7B2.2%7D%0A"></p><p>存在</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE_%7B%28w%2Cb%29%7D%3D(w%5E%7B*%7D%2Cb%5E%7B*%7D)%26%3D%5Cunderset%7B(w%2Cb)%7D%7Barg%20%5C%3B%20min%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(f(x_%7Bi%7D)%20-%20y_%7Bi%7D%20%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cunderset%7B(w%2Cb)%7D%7Barg%20%5C%3B%20min%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(y_%7Bi%7D%20-%20wx_%7Bi%7D%20-%20b%20%5Cright)%5E%7B2%7D%0A%5Cend%7Baligned%7D%09%5Ctag%7B2.3%7D%0A"></p><p>对<img src="https://math.now.sh?inline=E_%7B%28w%2Cb%29%7D" style="display:inline-block;margin: 0;">分别求偏导得</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cfrac%7B%5Cpartial%20E_%7B%28w%2Cb%29%7D%7D%7B%5Cpartial%20w%7D%20%3D%202%5Cleft(w%5Csum%5E%7Bm%7D_%7Bi%3D1%7Dx_%7Bi%7D%5E%7B2%7D%20-%20%5Csum%5E%7Bm%7D_%7Bi%3D1%7D(y_%7Bi%7D-b)x_%7Bi%7D%20%5Cright)%2C%5C%5C%0A%26%09%5Cfrac%7B%5Cpartial%20E_%7B(w%2Cb)%7D%7D%7B%5Cpartial%20b%7D%20%3D%202%5Cleft(mb%20-%20%5Csum%5E%7Bm%7D_%7Bi%3D1%7D(y_%7Bi%7D%20-%20wx_%7Bi%7D)%20%5Cright)%0A%5Cend%7Baligned%7D%0A%5Ctag%7B2.4%7D%0A"></p><p>二式联立并使偏导为零可得</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26w%20%3D%20%5Cfrac%7B%5Csum%5E%7Bm%7D_%7Bi%3D1%7Dy_%7Bi%7D%28x_%7Bi%7D%20-%20%5Cbar%7Bx%7D%29%7D%7B%5Csum%5E%7Bm%7D_%7Bi%3D1%7Dx_%7Bi%7D%5E%7B2%7D-%5Cfrac%7B1%7D%7Bm%7D%5Cleft(%5Csum%5E%7Bm%7D_%7Bi%3D1%7Dx_%7Bi%7D%20%5Cright)%5E%7B2%7D%7D%20%5C%5C%0A%26b%20%3D%20%5Cfrac%7B1%7D%7Bm%7D%5Csum%5E%7Bm%7D_%7Bi%3D1%7D(y_%7Bi%7D%20-%20wx_%7Bi%7D)%0A%5Cend%7Baligned%7D%0A%5Ctag%7B2.5%7D%0A"></p><p>其中<img src="https://math.now.sh?inline=%5Cbar%7Bx%7D%20%3D%20%5Cfrac%7B1%7D%7Bm%7D%5Csum%5E%7Bm%7D_%7Bi%3D1%7Dx_%7Bi%7D" style="display:inline-block;margin: 0;">为<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;">的均值。<br>
对于多元线性回归，取</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%3D%28%5Cboldsymbol%7Bw%7D%3Bb%29%5C%5C%0A%26%5Ctextbf%7BX%7D%3D%5Cbegin%7Bpmatrix%7D%0A%20x_%7B11%7D%20%20%26x_%7B12%7D%20%20%26...%20%26x_%7B1d%7D%20%261%5C%5C%20%0A%20x_%7B21%7D%20%20%26x_%7B22%7D%20%20%26...%20%26x_%7B2d%7D%20%261%20%5C%5C%20%0A%20%5Cvdots%20%26%5Cvdots%20%20%26%5Cddots%20%20%26%5Cvdots%20%20%26%5Cvdots%20%5C%5C%20%0A%20x_%7Bm1%7D%20%20%26x_%7Bm2%7D%20%20%26...%20%26x_%7Bmd%7D%20%261%20%0A%5Cend%7Bpmatrix%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%0A%5Cboldsymbol%7Bx%7D_%7B1%7D%5E%7BT%7D%20%261%5C%5C%0A%5Cboldsymbol%7Bx%7D_%7B2%7D%5E%7BT%7D%20%261%5C%5C%0A%5Cvdots%20%26%5Cvdots%20%5C%5C%0A%5Cboldsymbol%7Bx%7D_%7Bm%7D%5E%7BT%7D%20%261%0A%5Cend%7Bpmatrix%7D%5C%5C%0A%26%5Cboldsymbol%7By%7D%20%3D%20(y_%7B1%7D%3By_%7B2%7D%3B...%3By_%7Bm%7D)%0A%5Cend%7Baligned%7D%0A"></p><p>类同一元线性回归有</p>
<p style><img src="https://math.now.sh?from=E_%7B%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%7D%20%3D%20%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%5E%7B*%7D%20%3D%20%5Cunderset%7B%5Chat%7Bw%7D%7D%7Barg%5C%3B%20min%7D%28%5Cboldsymbol%7By%7D-%5Ctextbf%7BX%7D%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%29%5E%7BT%7D(%5Cboldsymbol%7By%7D-%5Ctextbf%7BX%7D%5Chat%7B%5Cboldsymbol%7Bw%7D%7D)%5Ctag%7B2.6%7D%0A"></p><p>对<img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7Bw%7D%7D" style="display:inline-block;margin: 0;">求导得</p>
<p style><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20E_%7B%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%7D%7D%7B%5Cpartial%20%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%7D%20%3D%202%5Ctextbf%7BX%7D%5E%7BT%7D%28%5Ctextbf%7BX%7D%5Chat%7B%5Cboldsymbol%7Bw%7D%7D-%5Cboldsymbol%7By%7D%29%20%5Ctag%7B2.7%7D%0A"></p><p>若有<img src="https://math.now.sh?inline=%5Ctextbf%7BX%7D%5E%7BT%7D%5Ctextbf%7BX%7D" style="display:inline-block;margin: 0;">为满秩矩阵(full-rank matrix)或正定矩阵(positive definite matrix)时，令偏导为零可得</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%5E%7B*%7D%20%3D%20%28%5Ctextbf%7BX%7D%5E%7BT%7D%5Ctextbf%7BX%7D%29%5E%7B-1%7D%5Ctextbf%7BX%7D%5Cboldsymbol%7By%7D%5C%5C%0A%26f(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D_%7Bi%7D)%3D%20%5Chat%7B%5Cboldsymbol%7Bx%7D%7D_%7Bi%7D%5E%7BT%7D%20(%5Ctextbf%7BX%7D%5E%7BT%7D%5Ctextbf%7BX%7D)%5E%7B-1%7D%5Ctextbf%7BX%7D%5Cboldsymbol%7By%7D%0A%5Cend%7Baligned%7D%0A%5Ctag%7B2.8%7D%0A"></p><p>此时有<img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7Bw%7D%7D%5E%7B*%7D%20%3D%20%28%5Cboldsymbol%7Bw%7D%3Bb%29" style="display:inline-block;margin: 0;">，则可将上式简写为<img src="https://math.now.sh?inline=y%20%3D%20%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%20%2B%20b" style="display:inline-block;margin: 0;">。<br>
考虑单调可微函数<img src="https://math.now.sh?inline=g%28%5Ccdot%29" style="display:inline-block;margin: 0;">，令</p>
<p style><img src="https://math.now.sh?from=y%20%3D%20g%5E%7B-1%7D%28%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%20%2B%20b%29%5Ctag%7B2.9%7D%0A"></p><p>得到一个“广义线性模型”(generalized linear model)，其中函数<img src="https://math.now.sh?inline=g%28%5Ccdot%29" style="display:inline-block;margin: 0;">称为“联系函数”(link function)。</p>
<h1>对数回归几率</h1>
<p>考虑二分类任务，其输出标记为<img src="https://math.now.sh?inline=y%20%5Cin%20%5C%7B0%2C1%20%5C%7D" style="display:inline-block;margin: 0;">，线性回归模型产生的预测值为<img src="https://math.now.sh?inline=z%20%3D%20%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%20%2B%20b" style="display:inline-block;margin: 0;">为实值。取对数几率函数(logistic function)</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ay%20%26%3D%20%5Cfrac%7B1%7D%7B1%2Be%5E%7B-z%7D%7D%5C%5C%0A%09%26%3D%20%5Cfrac%7B1%7D%7B1%2Be%5E%7B%28%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%20%2B%20b%29%7D%7D%0A%5Cend%7Baligned%7D%20%5Ctag%7B2.10%7D%0A"></p><p style><img src="https://math.now.sh?from=ln%20%5Cfrac%7By%7D%7B1-y%7D%20%3D%20%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%20%2B%20b%20%5Ctag%7B2.11%7D%0A"></p><p>若将<img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;">视为样本<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;">作为正例的可能性，则<img src="https://math.now.sh?inline=1-y" style="display:inline-block;margin: 0;">是其反例的可能性。二者的比值<img src="https://math.now.sh?inline=%5Cfrac%7By%7D%7B1-y%7D" style="display:inline-block;margin: 0;">称为“几率”(odds)，反映了<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;">作为正例的相对可能性。对纪律取对数得到“对数几率”(log odds，亦称logit)为<img src="https://math.now.sh?inline=ln%5Cfrac%7By%7D%7B1-y%7D" style="display:inline-block;margin: 0;">。<br>
可以看出对数回归几率实际上是在用线性回归模型的预测结果来逼近真实标记的对数几率。<br>
下面讨论如何确定上式中的<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;">。若将(2.10)式中的<img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;">视为后验概率估计<img src="https://math.now.sh?inline=p%28y%3D1%7C%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;">，则(2.11)式可重写为</p>
<p style><img src="https://math.now.sh?from=ln%5Cfrac%7Bp%28y%3D1%7C%5Cboldsymbol%7Bx%7D%29%7D%7Bp(y%3D0%7C%5Cboldsymbol%7Bx%7D)%7D%20%3D%20%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%20%2B%20b.%20%5Ctag%7B2.12%7D%0A"></p><p>显然有</p>
<p style><img src="https://math.now.sh?from=p%28y%3D1%7C%5Cboldsymbol%7Bx%7D%29%20%3D%20%5Cfrac%7Be%5E%7B%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%2Bb%7D%7D%7B1%2Be%5E%7B%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%2Bb%7D%7D%20%5Ctag%7B2.13%7D%0A"></p><p style><img src="https://math.now.sh?from=p%28y%3D0%7C%5Cboldsymbol%7Bx%7D%29%20%3D%20%5Cfrac%7B1%7D%7B1%2Be%5E%7B%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%2Bb%7D%7D%20%5Ctag%7B2.14%7D%0A"></p><p>通过“极大似然法”(maximum likelihood method)来估计<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D" style="display:inline-block;margin: 0;">和<img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;">。给定数据集<img src="https://math.now.sh?inline=%5C%7B%28%5Cboldsymbol%7Bx%7D_%7Bi%7D%2Cy_%7Bi%7D%29%20%5C%7D%5E%7Bm%7D_%7Bi%3D1%7D" style="display:inline-block;margin: 0;">，对率回归模型最大化“对数似然”(log-likelihood)</p>
<p style><img src="https://math.now.sh?from=%5Cell%28%5Cboldsymbol%7Bw%7D%2Cb%29%20%3D%20%5Csum%5E%7Bm%7D_%7Bi%3D1%7Dln%5C%20p(y_%7Bi%7D%7C%5Cboldsymbol%7Bx%7D_%7Bi%7D%3B%5Cboldsymbol%7Bw%7D%2Cb)%20%5Ctag%7B2.15%7D%0A"></p><p>即令每个样本属于其真实标记的概率越大越好。为便于讨论，令 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%3D%28%5Cboldsymbol%7Bw%7D%3Bb%29%2C%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3D(%5Cboldsymbol%7Bx%7D%3B1)" style="display:inline-block;margin: 0;">，则<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%5E%7BT%7D%5Cboldsymbol%7Bx%7D%2Bb" style="display:inline-block;margin: 0;">可简写为<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7BT%7D%5Chat%7B%5Cboldsymbol%7Bx%7D%7D" style="display:inline-block;margin: 0;">。再令<img src="https://math.now.sh?inline=p_%7B1%7D%28%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D%29%3Dp(y%3D1%7C%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)%2Cp_%7B0%7D(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)%3Dp(y%3D0%7C%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)%3D1-p_%7B1%7D(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)" style="display:inline-block;margin: 0;">，则式(2.15)中的似然项可重写为</p>
<p style><img src="https://math.now.sh?from=p%28y_%7Bi%7D%7C%5Cboldsymbol%7Bx%7D_%7Bi%7D%3B%5Cboldsymbol%7Bw%7D%2Cb%29%20%3D%20y_%7Bi%7Dp_%7B1%7D(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)%20%2B%20(1-y_%7Bi%7D)p_%7B0%7D(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)%20%5Ctag%7B2.16%7D%0A"></p><p>将(2.16)式代入(2.15)，并根据式(2.13)和(2.14)可知，最大化式(2.15)等价于最小化</p>
<p style><img src="https://math.now.sh?from=%5Cell%28%5Cboldsymbol%7B%5Cbeta%7D%29%20%3D%20%5Csum%5E%7Bm%7D_%7Bi%3D1%7D%5Cleft(-y_%7Bi%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7BT%7D%5Chat%7B%5Cboldsymbol%7Bx%7D%7D_%7Bi%7D%20%2B%20ln%5Cleft(%201%20%2B%20e%5E%7B%5Cboldsymbol%7B%5Cbeta%7D%5E%7BT%7D%5Chat%7B%5Cboldsymbol%7Bx%7D%7D_%7Bi%7D%7D%20%5Cright)%20%5Cright)%20%5Ctag%7B2.17%7D%0A"></p><p>式(2.17)是关于<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;">的高阶可导连续凸函数，根据凸优化理论，经典的数值优化算法如梯度下降法(gradient descent method)、牛顿法(Newton method)等都可以求得其最优解<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B*%7D%20%3D%20%5Cunderset%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%7Barg%5C%20min%7D%5C%20%5Cell%28%5Cboldsymbol%7B%5Cbeta%7D%29" style="display:inline-block;margin: 0;"><br>
对于牛顿法，其第<img src="https://math.now.sh?inline=t%2B1" style="display:inline-block;margin: 0;">轮迭代解的更新公式为</p>
<p style><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bt%2B1%7D%20%3D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bt%7D%20-%20%5Cleft%28%5Cfrac%7B%5Cpartial%5E%7B2%7D%5Cell(%5Cboldsymbol%7B%5Cbeta%7D%29%7D%7B%5Cpartial%5Cboldsymbol%7B%5Cbeta%7D%5Cpartial%5Cboldsymbol%7B%5Cbeta%7D%5E%7BT%7D%7D%20%5Cright)%5E%7B-1%7D%5Cfrac%7B%5Cpartial%5Cell(%5Cboldsymbol%7B%5Cbeta%7D)%7D%7B%5Cpartial%5Cboldsymbol%7B%5Cbeta%7D%7D%20%5Ctag%7B2.18%7D%0A"></p><p>其中关于<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;">的一阶、二阶导数分别为</p>
<p style><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%5Cell%28%5Cboldsymbol%7B%5Cbeta%7D%29%7D%7B%5Cpartial%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%3D%20-%5Csum%5E%7Bm%7D_%7Bi%3D1%7D%5Chat%7B%5Cboldsymbol%7Bx%7D%7D_%7Bi%7D(y_%7Bi%7D-p_%7B1%7D(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D))%2C%5C%5C%0A%5Cfrac%7B%5Cpartial%5E%7B2%7D%5Cell(%5Cboldsymbol%7B%5Cbeta%7D)%7D%7B%5Cpartial%5Cboldsymbol%7B%5Cbeta%7D%5Cpartial%5Cboldsymbol%7B%5Cbeta%7D%5E%7BT%7D%7D%20%26%3D%20%5Csum%5E%7Bm%7D_%7Bi%3D1%7D%5Chat%7B%5Cboldsymbol%7Bx%7D%7D_%7Bi%7D%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%5E%7BT%7D_%7Bi%7Dp_%7B1%7D(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)(1-p_%7B1%7D(%5Chat%7B%5Cboldsymbol%7Bx%7D%7D%3B%5Cboldsymbol%7B%5Cbeta%7D)).%0A%5Cend%7Baligned%7D%0A%5Ctag%7B2.19%7D%0A"></p>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
</search>
