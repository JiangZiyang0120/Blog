<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 1932. Merge BSTs to Create Single BST</title>
    <url>/2022/10/09/1932.merge-bsts-to-create-single-bst/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h2><div class="note danger simple"><p>This question should be a medium question 😂</p>
</div>
<p>This question doesn’t request any profound algorithms but does need to notice many details. Let’s build this tree step by step.<br>First, we need to find the tree’s root. And we can guarantee that the root node must exists only once. And it must be the only node exists only one time.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, TreeNode *&gt; val2Tree;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; val2count;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : trees)&#123;</span><br><span class="line">	val2Tree[t-&gt;val] = t;</span><br><span class="line">	++val2count[t-&gt;val];</span><br><span class="line">	<span class="comment">//to avoid dereferencing nullptr</span></span><br><span class="line">	++val2count[t-&gt;left ? t-&gt;left-&gt;val : <span class="number">0</span>];</span><br><span class="line">	++val2count[t-&gt;right ? t-&gt;right-&gt;val : <span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then, we could build the Tree from the root node</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : trees)&#123;</span><br><span class="line">	<span class="keyword">if</span>(val2count[t-&gt;val] == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//details</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//If there is no valid root node, we can&#x27;t build a BST</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>Now, we just need to link each node from top to bottom.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeLink</span><span class="params">(TreeNode *Tree, map&lt;<span class="keyword">int</span>, TreeNode *&gt; &amp;val2Tree, <span class="keyword">int</span> minLeft = INT_MIN, <span class="keyword">int</span> maxRight = INT_MAX)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// If this node has no child node, it is obviously valid</span></span><br><span class="line">	<span class="keyword">if</span> (Tree == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// We need to judge if this node satisfies the value scope of BST</span></span><br><span class="line">	<span class="keyword">if</span> (Tree-&gt;val &lt;= minLeft || Tree-&gt;val &gt;= maxRight)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// If Tree has no child(where Tree-&gt;left == nullptr == Tree-&gt;right),</span></span><br><span class="line">	<span class="comment">// find the node with the same value and link them.</span></span><br><span class="line">	<span class="keyword">if</span> (Tree-&gt;left == Tree-&gt;right) &#123;</span><br><span class="line">		<span class="keyword">auto</span> temp = val2Tree.<span class="built_in">find</span>(Tree-&gt;val);</span><br><span class="line">		<span class="comment">// If the node exists and be different from Tree</span></span><br><span class="line">		<span class="keyword">if</span> (temp != val2Tree.<span class="built_in">end</span>() &amp;&amp; Tree != temp-&gt;second) &#123;</span><br><span class="line">			Tree-&gt;left = temp-&gt;second-&gt;left;</span><br><span class="line">			Tree-&gt;right = temp-&gt;second-&gt;right;</span><br><span class="line">			<span class="comment">// after linking, we needn&#x27;t to notice this node anymore</span></span><br><span class="line">			val2Tree.<span class="built_in">erase</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// iteration from top to bottom.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* we need to adjust the child node&#x27;s scope, where its left child&#x27;s</span></span><br><span class="line"><span class="comment">	* max value shouldn&#x27;t be more than its value. And vice versa</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TreeLink</span>(Tree-&gt;left, val2Tree, minLeft, Tree-&gt;val) &amp;&amp;</span><br><span class="line">		   <span class="built_in">TreeLink</span>(Tree-&gt;right, val2Tree, Tree-&gt;val, maxRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Whole-Solution"><a href="#Whole-Solution" class="headerlink" title="Whole Solution"></a>Whole Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">TreeLink</span><span class="params">(TreeNode *Tree, map&lt;<span class="keyword">int</span>, TreeNode *&gt; &amp;val2Tree, <span class="keyword">int</span> minLeft = INT_MIN, <span class="keyword">int</span> maxRight = INT_MAX)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If this node has no child node, it is obviously valid</span></span><br><span class="line">        <span class="keyword">if</span> (Tree == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// We need to judge if this node satisfies the value scope of BST</span></span><br><span class="line">        <span class="keyword">if</span> (Tree-&gt;val &lt;= minLeft || Tree-&gt;val &gt;= maxRight)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// If Tree has no child(where Tree-&gt;left == nullptr == Tree-&gt;right),</span></span><br><span class="line">        <span class="comment">// find the node with the same value and link them.</span></span><br><span class="line">        <span class="keyword">if</span> (Tree-&gt;left == Tree-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = val2Tree.<span class="built_in">find</span>(Tree-&gt;val);</span><br><span class="line">            <span class="comment">// If the node exists and be different from Tree</span></span><br><span class="line">            <span class="keyword">if</span> (temp != val2Tree.<span class="built_in">end</span>() &amp;&amp; Tree != temp-&gt;second) &#123;</span><br><span class="line">                Tree-&gt;left = temp-&gt;second-&gt;left;</span><br><span class="line">                Tree-&gt;right = temp-&gt;second-&gt;right;</span><br><span class="line">                <span class="comment">// after linking, we needn&#x27;t to notice this node anymore</span></span><br><span class="line">                val2Tree.<span class="built_in">erase</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// iteration from top to bottom.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * we need to adjust the child node&#x27;s scope, where its left child&#x27;s</span></span><br><span class="line"><span class="comment">        * max value shouldn&#x27;t be more than its value. And vice versa</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeLink</span>(Tree-&gt;left, val2Tree, minLeft, Tree-&gt;val) &amp;&amp;</span><br><span class="line">               <span class="built_in">TreeLink</span>(Tree-&gt;right, val2Tree, Tree-&gt;val, maxRight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">canMerge</span><span class="params">(vector&lt;TreeNode *&gt; &amp;trees)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, TreeNode *&gt; val2Tree;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; val2count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t: trees) &#123;</span><br><span class="line">            val2Tree[t-&gt;val] = t;</span><br><span class="line">            ++val2count[t-&gt;val];</span><br><span class="line">            <span class="comment">//to avoid dereferencing nullptr</span></span><br><span class="line">            ++val2count[t-&gt;left ? t-&gt;left-&gt;val : <span class="number">0</span>];</span><br><span class="line">            ++val2count[t-&gt;right ? t-&gt;right-&gt;val : <span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t: trees) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val2count[t-&gt;val] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * If val2Tree&#x27;s size dosen&#x27;t equal to 1, there must be some </span></span><br><span class="line"><span class="comment">                * danling node which exists only once too.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">TreeLink</span>(t, val2Tree) &amp;&amp; val2Tree.<span class="built_in">size</span>() == <span class="number">1</span> ? t : <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If there is no valid root node, we can&#x27;t build a BST</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://leetcode.com/problems/merge-bsts-to-create-single-bst/">1932. Merge BSTs to Create Single BST</a></p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>LeetCode笔记</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>历周记(2022-10-03 - 2022-10-09)</title>
    <url>/2022/10/07/2022-w40/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>有两周没有发历周记了。一则是由于学业压力，暂且将历周记的时间间隔更改为两周一次。而第二周又是法定假日，于是满怀着罪恶感和摸鱼的心情又鸽了一周。名义上的理由如上，不过我现在感觉，这种每周找个时间来写作文的习惯有点没有意义。接下来，我想我会更倾向于将每日杂记整合进我的周记中。这或许会更青春废话文学，或许也会更贴近周记本身的意义。</p>
<h2 id="2022-10-07"><a href="#2022-10-07" class="headerlink" title="2022-10-07"></a>2022-10-07</h2><h3 id="我缺失的成长呢？"><a href="#我缺失的成长呢？" class="headerlink" title="我缺失的成长呢？"></a>我缺失的成长呢？</h3><p>9月27日素来是考研人破大防的日子。许多人会在这天失去悄悄保研的研友，更惨的是失去去向不一致而不得不分道扬镳的对象。更多的人破防，我想是在这一天，照见了自己碌碌无为的三年时光。至少我是如此。不过我当时并没有很emotional，而是挨个赞了过去。我和朋友圈&#x2F;空间中的不少人有交际，他们的确值得拥有这样的机会。<br>“昔日龌龊不足夸，今朝放荡思无涯。”看着空间里的几个大佬们保研清北亦或是申到QS TOP30，还是忍不住有些黯然。追望我的过去四年生活，除了些许有些值得纪念的点缀，和偶尔激起的学习热情，时间表上剩下的大片白茫茫的空洞，似乎在询问我逝去的时间究竟花在了什么上面。<br>本文无意追忆过去的生活，一来并没有什么意义，二来我也不愿写一些青春废话文学。本科学业的荒废其实在我意料之中。毕竟自己确实不喜欢我的本科专业，卷这个还不如写写hello world。只是确实觉得过去生活中有些遗憾的事情值得反思一下。<br>首先是没有找到可以长期固定交流的朋友。我日常生活中倒并不缺少朋友，总能找到一起看电影、刷夜，或者emo后一起深夜逛校园的朋友；再者我这人比较内向，独自一人并不会带给我什么精神内耗。所以我交朋友的倾向素来是朋友贵精不贵多。但我一直颇想找一个或数个可以交流那些心里冒出的想法，或一起研读一本书的朋友。其实我颇遇到了几位可以如此的朋友，甚至自己还在朋友圈办过几次有头无尾的读书会活动，找到了几位很聊得来的书友。只是我独来独往的性格，往往没几次就人走茶凉了。<br>其次是，我缺乏对生活的记录。这不仅造成了前文中，我追忆过去时大片的记忆空白；更糟糕的是，许多有价值的过去，我对它们的记忆只剩下几个苍白的词语——参与人、话题、什么事件——了。曾经和一些非常欣赏的人的对话，由于我糟糕而可笑的傲慢，最终总是变成一场辩论赛。而没有记录的情况下，这种习惯会更加糟糕，因为在辩论中，你往往只有立场和技巧，没有观点和交流。一场辩论下来，几乎不会得到什么启发。如果我没有在谈话后再去反思这些倏忽而过的sparks，那它们只能离我而去了。记录生活，这也是我开启周记的理由之一。<br>最后，我很遗憾我曾经辜负了不少人的期望。一个颇值得我写下来的，是某校队的队长。彼时的我闭门造车，对计算机科班学生的学习水平几无概念。怀着一腔勇气报名了某个获奖丰硕，能力和技术积累非常强的校队。出乎我对意料，那位队长对我颇为器重。不仅在一众能力很强的科班学生中选择了我，还交给了我一个很有挑战性的任务。记得一次和他讨论为什么会选择我时，他答道：“那天的面试让我感觉你挺特别的，不是那种会跟着学校安排走的学生。正好你在面试中说自己缺乏项目经验，就想帮你一下。”这番话令我颇为感动，在灿若星辰的浙大人中，不得不承受着自己曾经决策失误（选专业和对竺院仍留有最后一丝期望，没有转专业）的恶果，和自己并不好看的综合成绩终究是一件让人痛苦的事情。这位队长的话给了我很多力量——可惜那时的（也许还有现在的）我不配。课业的压力、考研的规划和我的怠惰、虚荣、自我；让我始终未能培养出足以接受那个任务的技术栈。最后借着疫情的缘故，无法跨校区的我和那个很棒的团队断了联系。那位队长，对我一定也很失望吧。<br>你看， life never gives anything for nothing, and that a price is always exacted for what fate bestows。我现在的痛苦，我现在瘠薄的技术栈，我缺失的选择权，早就在过去一次次对机会的虚掷中投下了筹码。如今输光黯然离场。</p>
<details class="toggle"><summary class="toggle-button" style>我对朋友的期许</summary><div class="toggle-content"><p>曾经在朵朵、98上都看过这样的贴子：一个同学自诩饱读诗书满腹经纶，却觉得自己始终找不到可以一起交流的人。希望自己能找一个对象，可以交流自己心中的那些惊涛骇浪和拈花一笑。<br>由于一位朋友的影响，我一贯认为，伴侣应该是集互相爱慕+三观相合+审美相近+共同爱好&#x2F;志趣的个体。如果找不到一个互相欣赏，进而可以互相忍耐的伴侣，婚姻连爱情都无法埋葬，只好埋葬柴米油盐酱醋茶和双方的龃龉，等填埋物超出了承受界限，只好炸出一地鸡毛。毕竟正值青春悸动，又怀着满腹的闷骚和中二，自然会幻想一个梦境中人来承载这些梦想。<br>这有点像我有一个很有才情的女性朋友。她真的很优秀，非常自律，学业优异的同时通熟国学、会弹古琴，下围棋，实属人类高质量女性。然而由于一些外部原因高考未能考中理想大学。她的情场比我得意许多，但同样未能找到称心的对象。我曾数次听她聊起自己的男朋友或追求者，总觉得对方关心有余，才情不足，无法和她对等交流。有一个男朋友对她很好，但对方缺乏足够的文学素养，这位女性朋友遂搬来四大名著唐诗宋词让他口诵心惟。数月后仍然不能满意，她男朋友（或是不感兴趣或是无法赶上进度）也颇为苦恼，遂分手。<br>从内心想法上，我觉得两个人无论是出于什么理由在一起，总以合适为第一要义。有龃龉或分歧，双方应当尽力交流和弥补。而若双方发现实在不合适了也不必强行弥补，好聚好散即可。但从感情上来说，我（僭越地）不太能认同这种“皮格马利翁”式的“弥补分歧”的行为。以我对这位女性朋友的浅薄认知和恶意揣测，若是她男朋友逼自己学完了汉赋唐诗宋词明小说，怕是还得学学手谈之技。她的（前）男朋友不过是这位她用于追逐自己心中的那抹幻影的一个工具。如果这位男朋友为了自己的爱意而化妆成一个幻影，他得到的又是爱吗？我不知道。<br>一个朋友&#x2F;伴侣满足自己的一切社交和情感需求是个很美妙的想法。但毕竟每个人都是独一无二的个体，没有谁是为谁而生的。即使我们浪漫地说，在茫茫人海中总会和合适的人相遇；从概率上来说，那个“合适的人”越具体，符合这个形象的个体也就越渺茫。如果不主动降低期待，就只能祈祷命运这只拉普拉斯妖为你扰动一下概率了。至于皮格马利翁，如果不是雅典娜的神迹，爱着的不过是一个雕像罢了，不是吗？罗翔老师说：”要爱具体的人，而非抽象的人。“大抵如此。<br>在过去的二十年人生中，我有幸遇到了几个非常符合我期待的朋友，这或许是由于我对朋友的期待相对低一点，但不管怎么说都是我极大的幸运。同时，我也不再汲汲于追求“完美”的朋友。苏东坡曾言：“吾上可以陪玉皇大帝,下可以陪卑田院乞儿。眼前见天下无一个不是好人。”放下层层的成见和标准后，更能发现一个人的可爱之处。<br>（可是对另一半，仍然放不下这种执念。留待之后继续思考吧）</p>
</div></details>

<h2 id="2022-10-08"><a href="#2022-10-08" class="headerlink" title="2022-10-08"></a>2022-10-08</h2><p>wakatime 已经连续给我发了两周邮件，提醒我码代码时长显著降低了。这些天忙着做题，二来手上也没什么项目。不过对一个计算机er来说，coding几乎是每日练手的必备流程了。还是要继续做LeetCode和参加周赛啊……</p>
<h2 id="2022-10-09"><a href="#2022-10-09" class="headerlink" title="2022-10-09"></a>2022-10-09</h2><p><img src="https://d.ifengimg.com/w625_h523_q90_webp/x0.ifengimg.com/res/2019/C84D225F2BB36A9C0A854A287CD41DE4CB62A9B5_size48_w625_h523.jpeg" alt="摸鱼纪实"><br>好歹做了点题，写了道LeetCode……</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>周记</category>
      </categories>
      <tags>
        <tag>weekly journal</tag>
      </tags>
  </entry>
  <entry>
    <title>历周记(2022-09-12 - 2022-09-18)</title>
    <url>/2022/09/18/2022-w37/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="对周记的一点思考"><a href="#对周记的一点思考" class="headerlink" title="对周记的一点思考"></a>对周记的一点思考</h2><p>我在这个博客发的第一篇周记中就说明了，我开这个周记主要是想逼迫自己输出倒逼输入。不过三周下来，我发现自己生活中值得记录的东西的确不多。考研人的生活往往朴实无华且枯燥。若是一板一眼地将我某某日做了什么题看了哪本书记录上来，那简直像是写我自己的使用说明书。难免不出三天就看不下去愤而删之了。但周记写成随笔集似乎也不大合适——我的“随笔”目录中全是一篇篇“历周记”，里面藏着真正的随感。这至少不大利于检索内容。<br>总的来说我还是尽可能地在找周记和我一周中的生活的巧妙配比。<del>当然我只是随口一说，不到下笔写周记时我根本不会去想这种事情。</del>也许什么时候会考虑将我每天的速记小卡片整合到我的周记中去，像上周周记那样的千字长文不妨单独摘出来当成博文发送。<br>另外一个问题就是周记对我的技术笔记输出量的挤压。这终究是个技术博客，我不太希望这个博客变成我的小树洞。在接下来的日子里我会尽力增加我的技术博客输出量（同时尽量保证质量），如果发现自己实在没办法平衡二者之间的数量和质量，我会考虑将周记变为双周记或干脆删掉并停更大批随笔部分的内容。<br>那么接下来，这周周记，让我们聊一些更琐碎，但又更贴近我一周生活的话题。</p>
<h2 id="Planing-Is-Nothing-Doing-Is-Everything"><a href="#Planing-Is-Nothing-Doing-Is-Everything" class="headerlink" title="Planing Is Nothing, Doing Is Everything"></a>Planing Is Nothing, Doing Is Everything</h2><p>其实上面说我不会在周记中记录我每天的学习状况，除了我不能忍受流水账外，还有一个原因——我的学习进度实际上根本不值得一记。这在考研只剩九十多天的日子里真的非常让人担心。我在状态非常好的时候，每天有效学习时间可以达到十个小时，但之后总会经历一两天的长时间摆烂。其他时候，我每天的有效学习时间实际上只有六个小时左右。当初看B站考研up主们一天10+小时的学习计划后也兴冲冲地自己制定了一份个人学习时间表——留足了充分的学习、午休和运动时间。但这份时间表似乎没给我带来什么好东西。<br>起初，它带给了我长达半个月的焦虑。这种焦虑我在<a href="https://jzy-planet.com/2022/09/04/2022-w35/">第一周周记</a>中描述过。我总会因为各种各样的事情耽误我满满当当的时间表，然后不得不熬夜、牺牲放松时间来弥补消失的学习进度。我学习的时间就越拖越晚。最后，我的作息时间直接颠倒了过来，晚上毫无困意，在床上颠来倒去一个多小时无果后，起床学到第二天早晨六点，吃完早点后困意马上到来。（这种恶劣作息让我一个假期胖了十公斤，现在正在艰难地减重。等减重成功当周，周记就水这个话题~）。再后来，它带给我“既然无法完成学习计划，那么明天一定”的习得性无助。我做了一个近乎完美的计划，为什么失败了呢？我想，也许很多时候，“做计划”是一种表演性行为，我们需要对“做计划”本身的重要性进行一个合理的评估。我想大概有如下几个考虑：</p>
<ol>
<li>做计划可能耗费巨大。一个对现实有指导意义的计划可能代价高昂，它需要对该计划的目标有足够的了解和调研，充分考虑现有资源才能完成。如果一个计划本身的代价高出我们所要完成的目的，就不值得了。比方说你不应该用两个小时来计划去哪里吃饭😂。</li>
<li>一个无法执行的计划没有任何价值。我想在做一件事情，尤其是一件长期性的事情时，需要认真地区分一下目的和手段，而手段永远应当，且只应当为这个目的服务。一个无法执行的，漂亮的计划书本身；除了发到社交媒体中完成一次表演行为获得一点点赞可能还有点价值外，是没有任何意义的。</li>
<li>不要忽视人月神话的魔力。一份计划的作用是减少执行过程中的无用步骤和选择代价，在加速项目本身方面并没有显著作用。所以在制定计划时不要对这份计划本身有过高期望。</li>
<li>永远不要忘记系统外干扰。今天离考研还有96天，所以我们就拥有96天的复习时间吗？绝非如此，你一定会遇到各种各样的事情挤占你的时间。包括但不限于其他考试、摆烂行为、社交应酬、生病抱恙等等。这种无法控制的突发事件的多少有一定部分取决于你对生活的控制程度和你断舍离的程度，但永远有一个下限。我的学习时间有多少？我会给它乘以一个80%的系数。所以只剩不到77天了。<del>完蛋！</del></li>
<li>提高执行力和执行效率永远是最关键的事情。不要把精力浪费在那些费而不惠的形式主义上了。</li>
</ol>
<h2 id="聊聊杨笠"><a href="#聊聊杨笠" class="headerlink" title="聊聊杨笠"></a>聊聊杨笠</h2><p>这是一个有些争议的话题。第一次听到杨笠是第三季脱口秀大会中，杨笠爆出了著名的“普通又自信”的梗。这个带有一些性别对立色彩，又上升全体男性的言论瞬间爆火，谩骂者和支持者皆众。随后又以“普信男”、“普信女”的meme存在于互联网中，成为网友们互相调侃和扣帽子的工具。不过黑粉也是粉，杨笠很是借这一波热度接了不少广告。<br>第四季脱口秀大会，杨笠或许有些路径依赖，又再一次爆了一波“性别对立”type的言论：“男人都是垃圾”。随后被一个人很巧妙地接了下去：“如果说男人是垃圾的话，那杨笠的最大愿望就是活在垃圾堆里。”从结构和技巧上来说，这个接法就比杨笠高级多了。<br>如果说第三季的“普通且自信”是对现实生活中的一些“爹味现象”的有力抨击，那第四季的这个段子就有些莫名其妙了。而从脱口秀的角度来说，这种单纯的谩骂——就跟骂一个人傻逼一样——其实没有任何幽默感可言；它并没有揭示自己想要讽刺的这部分群体内在的特性，也没有细挖这种矛盾性带来的幽默感，而只是单纯地将恶意当作笑点。只是一种大范围的“伦理梗”罢了。其实看到这里我是颇为失望的，脱口秀大会中其实输出了不少具有平权精神的段子，如这一季颜怡颜悦关于“女性衣服口袋”，和鸟鸟的“下厨房”段子，都非常不错；但爆火的如果竟是这种单纯的谩骂，不禁让人有些叹服于现在的性别对立程度。<br>当然，这一季的杨笠颇给了我一些惊喜。靠煽动男女对立获得了如此多流量的她，不再凭借这一手段吸引流量，而是很认真地说想要靠一些技术性的段子来参赛。希望她能够探索出更加优秀的风格。</p>
<p>由于时间关系，暂且聊一点吧。以后或许会单独开一个随笔页，好好聊一聊我的观点。</p>
<p>那就祝大家在下周快乐！</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>周记</category>
      </categories>
      <tags>
        <tag>weekly journal</tag>
      </tags>
  </entry>
  <entry>
    <title>历周记(2022-09-05 - 2022-09-11)</title>
    <url>/2022/09/10/2022-w36/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>又是一周结束的日子。这周经历了咽喉溃疡、返校、隔离、做核酸捅喉咙……只觉得浑浑噩噩了好几天；没想到这么快就又到了一周结束的日子了。普通人的生活，往往要拿着放大镜才能找到些许值得记录的片段的。想了想，过去一周好像没什么特别值得记录的。那就写点务虚的吧。</p>
<h2 id="诗心和远去的诗心"><a href="#诗心和远去的诗心" class="headerlink" title="诗心和远去的诗心"></a>诗心和远去的诗心</h2><p>在我很小的时候，曾一度非常喜欢诗词。虽然最早接触诗词的原因是为了和女孩子聊天有话题，但很快，我就被诗词迷住了。找话题时抱着厚厚的书籍，也颇有种醉翁之意不在酒的意味了。小时候品味不是很高，看多了汉赋和婉约词，只觉极尽华丽之辞藻，欲穷天工之文章。读这些文字就好像看到了一幅幅画卷，看到风起于青蘋之末，草色摇动；看到三秋桂子，十里荷花；看到小姑娘着袜欲走，却又装作嗅着青梅，倚门偷偷望着来客……<br>我很幸运地没有学到这些文字的风格，不至于写出一堆拙略模仿，臭不可闻的生僻词叠叠乐。但这些文字确实让幼时的我感受到了文字的美。现在想来，那大概是我为数不多地，满怀好奇与激动探索一本书的时光；也是我绝无仅有的，为了和女孩子聊天那么认真的时光了。<br>再后来，审美水平有所提高，我开始接触诗词的风格也渐渐流变。豪放派、浪漫派等等不一而足。除了对李太白的诗词感到高山仰止深深叹服外，苏轼、苏门弟子、姜夔等许多词人的作品我也非常喜欢。除了李杜这个无法攀爬的高峰外，我最喜欢的大概是辛弃疾了吧。无论是《破阵子》、《水龙吟》等满怀豪情壮志的词，抑或是《菩萨蛮》、《水调歌头·壬子三山被召陈端仁给事饮饯席上作》的怀才不遇。颇记载了那时颇孤独内向，又有些中二的心路。<br>除了看诗，我还有抄诗的“癖好”。初高中、大一大二时，每当心事不畅郁郁于怀，抑或是闲来无事时，我都会郑重其事地拿出我的诗抄笔记本，翻开一本诗词集，抄！于是，每当一年结束，我就会拥有一本写得满满当当的笔记本，里面记着许多诗句题注。我在这一本本诗抄中练会了一手野生的硬笔瘦金，也背会了几句可以触景生情的诗句。这几首诗词，和我闲来看过的几本杂书、几篇古文颇让我找到了几个文科的朋友一起交流观点。<br>这一切，看起来都像是一个典型的文青才会干的事情。然而，随着时间的流逝，我似乎渐渐地失去了这份诗心。很难说这种改变是源于哪个特殊事件；我只是选择将我的《诗词格律》放在了家里；然后将我的诗词书籍放在书橱而非床头案头；然后让它在书橱里蒙尘。我的书柜上渐渐不见了诗词集，而是一本本没读完的社会学、历史学著作，随手要查的机械工业出版社大黑书和永远在待读名单里的小说。再后来，越来越多的计算机书籍将这些社科类书籍也挤了下去。我发现自己再没有雅兴打开一本诗词集细细揣摩，更没有心情去坐着抄诗了。<br>然而，本文并非旨在描绘一个文青的远去，也无意于在这个基础上伤春悲秋一番。我曾和一个朋友聊天时谈起了“诗心已死”的问题，那位朋友很焦急地说：“这个问题很严重啊！”而我笑了笑：“其实不然。”在我看来，诗词的离去于我而言并非美感的丧失，而仅仅是一次爱好的流变。我对诗词的喜爱停留，停留，也仅仅停留在了欣赏的阶段。在阅读了大量优秀的诗词后，颇有些“曾经沧海难为水”之情，不太看得下去那些次一等的诗作了。而我一来没有养成创作爱好；二来国内的古体诗词人才凋敝，难以接触更多更好的作品。至少古诗词领域，想要寻找让我感兴趣的作品相对越来越难了。也是时候和古诗词说再见了。我想这也并不能意味着我对“美”的感受丧失了（虽然我的确越来越像个理科生了），我的生活中仍然有绘画，有音乐，有社科的思考，有严密架构于数学、物理之上，令我无比好奇的计算机科学。它们就像曾经的诗词那样吸引着我。<br>某种程度上说，这种爱好的流变和恋爱有一定的相似处。出于内心的悸动和对方的吸引，你热情地将对方邀进了你的生活。对方的爱好、兴趣、闪光点和习惯影响你良多。如果出于种种原因，对方不能和你一直走下去了。很自然地，你可能不得不面对生活中逐渐消失的，对方的痕迹。但对方曾经影响过你的那些事情，或强烈或微弱地，还是会润物无声地在你身上体现出来。<br>这次周记由于时间原因，并没有在当周周天完成，一直拖到了次周的周二。在这天，台风“梅花”为杭州带来了连天的阴雨，并将持续影响后面两天的风雨气候。现在，窗外正下着不小的雨。“帘外雨潺潺，春意阑珊，罗衾不耐五更寒。”这首李后主的词蓦然蹦了出来。杭州的晚风和雨声中，似乎遥遥感受到了李后主的凭栏意（准备考研时也是这种感受）。诗心远去了，诗词对我的影响并不会远。<br>谢谢你来过。</p>
<h2 id="本周学习回顾"><a href="#本周学习回顾" class="headerlink" title="本周学习回顾"></a>本周学习回顾</h2><p>本周除了返校、隔离的种种时间消耗外，整体上稳步进行着。在学习之余，我关注并阅读了挺多相关的技术博客来增加我的外语阅读量，也提高我对相关方向的了解。但仍然无法满效率地执行我的学习时间表。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>周记</category>
      </categories>
      <tags>
        <tag>weekly journal</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 188. Best Time to Buy and Sell Stock IV</title>
    <url>/2022/09/10/188.best-time-to-buy-and-sell-stock-iv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h2><p>This is another dynamic programming problem similar to <a href="https://jzy-planet.com/2022/09/01/1687.delivering-boxes-from-storage-to-ports/">1687. Delivering Boxes from Storage to Ports</a>. And however, with a limitation of purchase times. We can just use two iteration on this question. One is the iteration of vector prices(obviously), and another is the iteration of purchase times k.<br>What’s more, we need to purchase a good before selling it. Thus we need to record the purchases. And the code is as below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; price)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">profit</span><span class="params">(<span class="number">2</span>*k+<span class="number">1</span>, INT_MIN)</span></span>;</span><br><span class="line">        <span class="comment">//if we do nothing, the profit is 0 without doubt</span></span><br><span class="line">        profit[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//the iteration of prices vector</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; price.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="comment">//the iteration of transaction times</span></span><br><span class="line">			<span class="comment">/*for each i, profit[i+1] is the profit with a good in stock,</span></span><br><span class="line"><span class="comment">			 *and profit[i+2] is the profit after selling goods.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+<span class="number">2</span> &lt;= <span class="number">2</span>*k; i += <span class="number">2</span>)&#123;</span><br><span class="line">                profit[i+<span class="number">1</span>] = <span class="built_in">max</span>(profit[i+<span class="number">1</span>], profit[i]-price[j]);</span><br><span class="line">                profit[i+<span class="number">2</span>] = <span class="built_in">max</span>(profit[i+<span class="number">2</span>], profit[i+<span class="number">1</span>]+price[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(profit.<span class="built_in">begin</span>(), profit.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://jzy-planet.com/2022/09/01/1687.delivering-boxes-from-storage-to-ports/">1687. Delivering Boxes from Storage to Ports</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/2555708/Easy-solution-Explained-oror-Beginner-Friendly-oror-Best-Method">✅Easy solution Explained || Beginner Friendly 🔥||✔️ Best Method</a></p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>LeetCode笔记</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>历周记(2022-08-29 - 2022-09-04)</title>
    <url>/2022/09/04/2022-w35/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这是我在博客上写的第一篇周记，希望能用周记的形式来记录自己的生活和一些感悟。也能用输出倒逼输入的方式让自己去更多地涉猎一些内容。我始终觉得文理科并不是人生必须二选一的选项，一个程序工程师同样需要人文情怀和人文素养，才能更好地开发出吸引和满足他人诉求的产品。<br>我在上一周，乃至过去的一个月每天晚上都习惯性地开始写代码，一直熬到深夜解决问题才上床。然后被蓝光辐射地毫无困意，打开社交媒体刷刷刷，一直刷到昏昏沉沉地睡去。第二天被闹铃叫醒，也才堪堪睡够六个小时。时间一长，生物钟就彻底乱掉了，我开始间歇性嗜睡、感冒流涕不止，每日跑步也感觉跑不动了。这让我开始思考一个WLB(Work&amp;Life Balance) 的问题。这也是本次周记的话题。</p>
<h2 id="如何看待-WLB"><a href="#如何看待-WLB" class="headerlink" title="如何看待 WLB"></a>如何看待 WLB</h2><p>对许多大学学生而言，我们对 WLB 其实缺乏清晰的认知。一方面，学生，尤其是大学生，并没有严格的工作与时间的界限。出于个人规划与目标的不同，日日刷图书馆者有之，爆肝做项目者有之，每天摸鱼直到考试周熬夜补天者亦有之。  另一方面，学生的工作时间往往不怎么受到重视（因为大学生是极好的廉价劳动力），时常是召之即来挥之即去，这也导致学生的工作&#x2F;学习时间极不固定。<br>这种大学生活虽给了我们极大的自由，让我们可以根据自己需求来分配时间，但我认为在某种程度上这并不是一种好事。一方面，我们需要养成对“工作”的概念，找到自己认可的，能够实现自我价值的事业，然后不断精进——注意，这里需要的是一种自发而自觉的工作；另一方面，我们也需要掌握调剂工作与生活的艺术，找到适合自己的工作节奏和享受生活的态度。从这种意义上来说，八小时工作制是一种很值得借鉴的生活方式——每日给工作留足一定的时间，剩下的时间用于享受生活（当然，也可以用于发展兴趣、探索不同于日常工作的，可以提升自己的那一部分），总之，与工作保留出足够的距离。以免过快地消耗自己的激情和发展潜力。<br>在两天前，我终于堪堪调整好了自己的生物钟，也进一步规划好了自己的学习时间表。主要任务就是把自己的编程和学习计算机知识的活动调到下午，以免自己沉迷学习无法自拔，再次陷入熬夜的不良循环中去。但是终极目标仍然是坚持自己的时间表，不要为任务所困。到点后，记录完自己的状态和todo-list，然后迅速回归生活。不要陷入周期性的<a href="https://asana.com/zh-tw/resources/parkinsons-law">帕金森</a>危机中去。</p>
<h2 id="时间冗余的最大杀手"><a href="#时间冗余的最大杀手" class="headerlink" title="时间冗余的最大杀手"></a>时间冗余的最大杀手</h2><p>该条引自<a href="https://twitter.com/Svwang1">硅谷王川</a>的推特：</p>
<blockquote>
<p>最重要的一个冗余是时间冗余，有大把的闲暇时间去做自己愿意做的事情，而把在不愿意做的事情上耗费的时间尽量压缩到接近于零。</p>
<p><strong>时间冗余的第一个杀手是：浪费时间去辩论，或试图说服认知不同的人接受自己的观点。</strong> </p>
<p>时间冗余的第二个杀手，是没有把自己经常要做的一些事情自动化，然后发现自己忘了，又要耗费时间精力再人工干预。 </p>
<p>时间冗余的第三个杀手，<strong>是没有注重于可以不断多次重复使用，积累的行为；而耗费大量精力在低价值，无法重复利用的行动上。</strong> </p>
<p>时间冗余的第四个杀手，是没有勇气和意愿隔断各种低效甚至有伤害性的社交应酬，让一些 sb 随便的接近你的空间，或者允许一些群体的错误风气潜移默化的干扰你的独立思考。 </p>
<p>时间冗余的第五个杀手，是没有注意“节制饮食 - 适度运动 - 充足睡眠”, 随着年龄增长，各种肩酸背痛，视力下降，神经衰弱，高血糖血脂，心血管等毛病不断加剧，恶性循环，脾气也越发暴戾，迅速滑向老年痴呆，成了一个事实上的废人。 </p>
<p>时间冗余的第六个杀手，是本来可以花 N 小时把一个事情做得差不多足够好就收手了，硬是要花 3N, 4N 甚至更多倍的时间，仅仅把效益再提高百分之几而已，甚至画蛇添足，多余的努力反而把事情搞砸了。 </p>
<p>判断自己”时间冗余”的水平的一个角度是，你如果什么都不做，一个月，三个月，甚至像 Rip Van Winkle 一样睡很多年的觉再醒来，你的状况 (财务或者别的方面) 是不是可以维持现状，甚至会变得比现在更好? 如果有哪些地方需要人工干预，是否可以现在就未雨绸缪，把它预先自动设置好？ </p>
<p>“时间冗余”并不完全等同于“高效率”，另一个角度是当意识到自己的方向是错误的时候，可以迅速调整纠错的能力。如果方向错误，意识到错误后因为各种限制而无法迅速抽身离开，那么不管效率多高，也是枉然。 </p>
<p>任何事情，如果不能随时抽身离去，而要时常事必躬亲，是一个潜在的时间上的负资产，是对时间冗余的巨大损害。往往一开始没有在意，出了问题后才意识到代价巨大。</p>
</blockquote>
<p>我们往往意识不到时间是多么地宝贵，以致于将它轻掷到那些没有价值的地方去，陷入无底的时间漩涡无法自拔。我非常认可这个“时间冗余”的做法，以前也花了很多的经历来探索“自动化工具流”。但这段话的确给了我更多的启示：将时间浪费地画在不值得的地方同样是一种不负责任。如果必须浪费时间，那就将时间浪费给自己和自己爱的人身上吧。若是无谓地虚掷时间而想要获得快乐，斯以伐根而求木茂，塞源而欲流长也。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>周记</category>
      </categories>
      <tags>
        <tag>weekly journal</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1687. Delivering Boxes from Storage to Ports</title>
    <url>/2022/09/01/1687.delivering-boxes-from-storage-to-ports/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h2><p>As the dynamic programming solution’s max time complexity is $\text O(n^2)$. We could simply get the first solution:<br>This Code comes from <a href="https://leetcode.com/linshan007/">linshan077</a>. And it is almost the best implement of DP. Where the trip assist to decline the cost of repeatedly judging <code>boxes[j][0] == boxes[j-1][0]</code> and <code>dp</code> is the common implement of dynamic programming.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">boxDelivering</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; boxes, <span class="keyword">int</span> portsCount, <span class="keyword">int</span> maxBoxes, <span class="keyword">int</span> maxWeight)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">trips</span><span class="params">(boxes.size())</span></span>;</span><br><span class="line">        trips[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; boxes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (boxes[i][<span class="number">0</span>] == boxes[i<span class="number">-1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                trips[i] = trips[i<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                trips[i] = trips[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i+1] is minimum trips assuming i is the last box to deliver and will return to port afterwards. </span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(boxes.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boxes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>] = INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> sum_weights = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&gt;=<span class="number">0</span> &amp;&amp; i-j+<span class="number">1</span> &lt;= maxBoxes; --j) &#123;</span><br><span class="line">                sum_weights += boxes[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (sum_weights &gt; maxWeight) <span class="keyword">break</span>;</span><br><span class="line">                dp[i+<span class="number">1</span>] = std::<span class="built_in">min</span>(dp[i+<span class="number">1</span>], dp[j]+<span class="number">2</span>+trips[i]-trips[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>However, it got a TLE.  And we translate<code>min(dp[j]+2+trips[i]-trips[j])</code> into <code>2+trips[i]+min(dp[j]-trips[j])</code>. It turns to a question: find the minimum in a Slide window(Which we can easily solve by a deque with total time complexity $\text O(n)$).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">boxDelivering</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; boxes, <span class="keyword">int</span> portsCount, <span class="keyword">int</span> maxBoxes, <span class="keyword">int</span> maxWeight)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">trips</span><span class="params">(boxes.size())</span></span>;</span><br><span class="line">        trips[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; boxes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (boxes[i][<span class="number">0</span>] == boxes[i<span class="number">-1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                trips[i] = trips[i<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                trips[i] = trips[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; <span class="title">weights</span><span class="params">(boxes.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        weights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boxes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            weights[i+<span class="number">1</span>] = weights[i]+boxes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(boxes.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span>&gt; <span class="title">weight</span><span class="params">(boxes.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        weight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i != boxes.<span class="built_in">size</span>()+<span class="number">1</span>; ++i)</span><br><span class="line">            weight[i] = weight[i<span class="number">-1</span>] + boxes[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        deque&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; dq;</span><br><span class="line">        <span class="keyword">int</span> temp, totalWeight, totalBoxes;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,dp[<span class="number">0</span>] - trips[<span class="number">0</span>]&#125;);</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span> + trips[<span class="number">0</span>] + dq.<span class="built_in">front</span>().second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; boxes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            temp = dp[i] - trips[i];</span><br><span class="line">            <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>().second &gt; temp)</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            dq.<span class="built_in">push_back</span>(&#123;i,temp&#125;);</span><br><span class="line">            totalWeight = weight[i+<span class="number">1</span>] - weight[j];</span><br><span class="line">            totalBoxes = i - j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (totalWeight &gt; maxWeight || totalBoxes &gt; maxBoxes)&#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                j = dq.<span class="built_in">front</span>().first;</span><br><span class="line">                totalWeight = weight[i+<span class="number">1</span>] - weight[j];</span><br><span class="line">                totalBoxes = i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i+<span class="number">1</span>] = <span class="number">2</span> + trips[i] + dq.<span class="built_in">front</span>().second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above code deducts the cost of  repetitive calculation of <code>dp[i+1] = std::min(dp[i+1], dp[j]+2+trips[i]-trips[j])</code> And turns $\text O(mn)$(where m is the maxBoxes) into $\text O(n) + \text O(n) &#x3D; \text O(n)$.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/1369248/C%2B%2B-DP-solution-with-thinking-process%3A-brute-force-greater-priority-queue-greater-mono-queue">C++ DP solution with thinking process: brute force -&gt; priority queue -&gt; mono queue</a></li>
<li><a href="https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/2330389/Java-or-From-O(N2)-to-O(N)-or-MonoQueue-w-DP">Java | From O(N^2) to O(N) | MonoQueue w&#x2F; DP</a></li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>LeetCode笔记</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的 0/3/5 规则</title>
    <url>/2022/08/30/c-0-3-5-rule/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>编程三大错觉：<br>我比编译器聪明<br>我超越了标准库<br>我能管好内存</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>由于最近在看《算导》，我就萌生了实现算导的想法。之前实现的线表List.h文件一直稳定运作，但在经历了单元测试并稳定运行数天后，当我将它应用到我的新代码部分时，出现了一个bug。<br>我的代码文件如下：<br>List.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>() : <span class="built_in">head</span>(<span class="keyword">new</span> class Node&lt;T&gt;), <span class="built_in">tail</span>(<span class="keyword">new</span> class Node&lt;T&gt;) &#123;</span><br><span class="line">        head-&gt;nextNode = tail;</span><br><span class="line">        tail-&gt;prevNode = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">List</span>(T rs) : <span class="built_in">List</span>() &#123;</span><br><span class="line">        <span class="built_in">insert</span>(rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">List</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (class Node&lt;T&gt; *pointer = tail; pointer != head;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = pointer;</span><br><span class="line">            pointer = pointer-&gt;prevNode;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T rs)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">auto</span> pointer = <span class="keyword">new</span> class Node&lt;T&gt;(rs, tail-&gt;prevNode, tail);</span><br><span class="line">    	tail-&gt;prevNode = pointer;</span><br><span class="line">    	pointer-&gt;prevNode-&gt;nextNode = pointer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>, <span class="keyword">class</span> <span class="title">Edge</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdjacentList</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::map&lt;shared_ptr&lt;Vertex&gt;,List&lt;Edge&gt;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>, <span class="keyword">class</span> <span class="title">Edge</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AdjacentList&lt;Vertex, Edge&gt;::<span class="built_in">insert</span>(std::shared_ptr&lt;Vertex&gt; origin, std::shared_ptr&lt;Vertex&gt; next, <span class="keyword">double</span> w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!graph[origin])</span><br><span class="line">        graph[origin] = List&lt;Edge&gt;();</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">Edge</span>(next, w);</span><br><span class="line">    graph[origin].<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来给你三分钟，试试能不能找出bug在哪？</p>
<p>如果你找不出bug在哪里，请接着往下看：<br>C++为我们提供了强大的智能指针，用来管理资源的生命周期。大部分情况下我们只要用好智能指针来管理资源就好。不过在某些情况下，我们可能会遇到空间不足，或是需要自定制的资源管理类。然而，编写资源管理类很困难，你很难检测和排除内存泄漏或空悬指针的现象。<br>回到我们上面的这个函数，bug实际上出现在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!graph[origin])</span><br><span class="line">        graph[origin] = List&lt;Edge&gt;();</span><br></pre></td></tr></table></figure>

<p>这里。在这里，我们不是初始化，而是使用复制赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassType &amp;operate=(ClassType &amp;rs);</span><br></pre></td></tr></table></figure>

<p>为map的second值赋值。由于我们的List类并没有自定义复制赋值运算符，C++的默认复制赋值运算符的操作是将原来类的每一个成员变量赋值给新的类。所以这里，<code>graph[origin]</code>得到了一个<code>List&lt;Edge&gt;()</code>类的head和tail指针（注意，这样非常危险！要么两个List在同一块链表上进行插入删除操作，要么造成内存泄漏的后果）<br>我们在List的insert函数处打一个断点，看看会发生什么：<br><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1661856814/gxKom_ztdkff.png" alt="debug1"><br>可以看到，<code>graph[origin]</code>的head和tail的前后指针良好。但我们再执行一步看看：<br><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1661856811/J6n22_szifw4.png" alt="debug2"><br>你会发现：变量pointer竟指向一个“已分配”的指针<code>graph[origin].head</code>！这是为什么呢？<br>其实到这里问题已经比较清晰了：为<code>graph[origin]</code>赋值的<code>List&lt;Edge&gt;()</code>是一个右值，在完成赋值语句之后就被析构了。我们自定义的析构函数从tail开始逐个向前，将所有指针指向的资源释放掉。那为什么在dubugger这里还能看到head、tail和它们指向的值呢？这是因为编译器在将资源返回给动态内存池的时候不会执行置零操作，而是简单地将该地址入栈等待下一次调用。所以指向该地址的类仍然可以解释————虽然它早已被析构了。<br>那这种问题怎样解决呢？一种方式是正常调用它的构造函数以便之后调用成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!graph[origin])</span><br><span class="line"><span class="comment">//construct graph[origin]</span></span><br><span class="line">      graph[origin];</span><br></pre></td></tr></table></figure>

<p>但另一个更重要的操作是，更改List的类函数</p>
<h2 id="0-x2F-3-x2F-5规则"><a href="#0-x2F-3-x2F-5规则" class="headerlink" title="0&#x2F;3&#x2F;5规则"></a>0&#x2F;3&#x2F;5规则</h2><h3 id="零规则"><a href="#零规则" class="headerlink" title="零规则"></a>零规则</h3><p>规则的零部分规定，在创建类时，你可以不编写任何特殊成员函数（而由编译器默认生成）。</p>
<h3 id="三规则"><a href="#三规则" class="headerlink" title="三规则"></a>三规则</h3><blockquote>
<p>如果你的类需要任何</p>
<ul>
<li>一个复制构造函数，</li>
<li>赋值运算符，</li>
<li>析构函数，</li>
</ul>
<p>明确定义，那么很可能需要这三个。</p>
</blockquote>
<p>因为它们三个通常都用于管理资源，如果你的类用来管理资源，则通常需要管理复制和释放。<br>如果复制类管理的资源没有良好的语义，则考虑通过将复制构造函数和赋值运算符声明为<code>=delete;</code>（鼓励）或放入 private scope 并不进行定义。</p>
<h3 id="五规则"><a href="#五规则" class="headerlink" title="五规则"></a>五规则</h3><p>在三规则的基础上，C++11标准引入了右值。所以还需要考虑移动构造函数和移动赋值函数，即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassExample</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">ClassExample</span>() = &#123;<span class="comment">/*details or default*/</span>&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">ClassExample</span>(ClassExample &amp;) = &#123;<span class="comment">/*details or default*/</span>&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">ClassExample</span>(ClassExample &amp;&amp;) = &#123;<span class="comment">/*details or default*/</span>&#125;</span><br><span class="line">	</span><br><span class="line">	ClassExample &amp;<span class="keyword">operator</span>=(ClassExample &amp;) = &#123;<span class="comment">/*details or default*/</span>&#125;</span><br><span class="line">	</span><br><span class="line">	ClassExample &amp;<span class="keyword">operator</span>=(ClassExample &amp;&amp;) = &#123;<span class="comment">/*details or default*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h2><p>我们增加移动赋值操作的定义，可以练习一下其他几个函数的定义。<br>由于List类的<code>head</code>和<code>tail</code>为哨兵元素，我们无需考虑，也无需复制。而是将List类中的元素复制过来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	List&lt;T&gt; &amp;<span class="keyword">operator</span>=(List&lt;T&gt; &amp;&amp;rs)&#123;</span><br><span class="line">		<span class="comment">//free this class&#x27;s element but reserve guard elements</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> pointer = tail-&gt;prevNode; pointer != head;)&#123;</span><br><span class="line">			<span class="keyword">auto</span> temp = pointer;</span><br><span class="line">			pointer = pointer-&gt;prevNode;</span><br><span class="line">			<span class="keyword">delete</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//duplicate rs&#x27; elements</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> pointer = rs.head-&gt;nextNode; pointer != rs.tail; pointer = pointer-&gt;nextNode)&#123;</span><br><span class="line">			<span class="built_in">insert</span>(*pointer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>coding过程中踩过的坑</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>linux如何通过SMTP服务器发送QQ邮件</title>
    <url>/2022/06/28/linux-ru-he-tong-guo-smtp-fu-wu-qi-fa-song-qq-you-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这是《计算机网络——自顶向下方法》里的一个小实验，对理解smtp的交流和电子邮件的报头都很有帮助。是个很值得尝试的实验。</p>
<p>首先，我们需要下载 telnet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install telnetd -y</span><br></pre></td></tr></table></figure>

<p>其次，按照这个文档所示的方式开启QQ邮箱的SMTP服务<br><a href="https://www.ujcms.com/documentation/351.html"># 使用QQ邮箱发送邮件，QQ邮箱的smtp设置</a><br>并记住自己的身份认证密码。</p>
<p>接下来，打开linus系统的<strong>xshell</strong>（快捷键 ctrl+alt+T），输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet smtp.qq.com 25</span><br></pre></td></tr></table></figure>

<p>会看到如下返回：<br><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1657184045/Pasted_image_20220627002748_uocva7.png" alt="terminal"></p>
<p>依次输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auth login  //输入命令验证身份</span><br><span class="line">334 VXNlcm5hbWU6  //服务器返回Username:的base64编码符</span><br><span class="line">******** //输入自己邮箱号，例123456789@qq.com的base64编码值</span><br><span class="line">334 UGFzc3dvcmQ6  //服务器返回Password:的base64编码符</span><br><span class="line">******** //输入自己身份认证密码的base64编码值</span><br><span class="line">235 Authentication successful  //连接成功</span><br></pre></td></tr></table></figure>

<p>base64编码可以上网随便找转换工具，保险起见邮箱号和身份认证密码分别用两个不同的网站编码。或自己写一个也行。</p>
<p>连接成功后就可以按照书上的步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Helo ****  //主机名，可填邮箱号</span><br><span class="line">250-newxmesmtplogicsvrsza9.qq.com-9.21.152.27-66638923</span><br><span class="line">250-SIZE 73400320</span><br><span class="line">250 OK</span><br><span class="line">mail from: &lt;123456789@qq.com&gt; //填你的邮箱号</span><br><span class="line">250 OK</span><br><span class="line">rcpt to: &lt;123456789@gmail.com&gt;  //填你想发送的邮箱号</span><br><span class="line">250 OK</span><br><span class="line">data</span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;.</span><br><span class="line">//报头必不可少，否则可能被当成垃圾邮件退回</span><br><span class="line">From: 123456789@qq.com</span><br><span class="line">To: 123456789@gmail.com</span><br><span class="line">Subject: It may be a huge joke!</span><br><span class="line"></span><br><span class="line">Just a test</span><br><span class="line">Could you reach this message?</span><br><span class="line">.</span><br><span class="line">250 OK: queued as.</span><br></pre></td></tr></table></figure>

<p>随后，就能成功收到这份邮件了！<br><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1657184045/Pasted_image_20220627004011_n06trm.png" alt="接收邮件"></p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>黎明静悄悄</title>
    <url>/2021/09/07/li-ming-jing-qiao-qiao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="黎明静悄悄"><a href="#黎明静悄悄" class="headerlink" title="黎明静悄悄"></a>黎明静悄悄</h1><h2 id="子夜"><a href="#子夜" class="headerlink" title="子夜"></a>子夜</h2><blockquote>
<p>She was still too young to know that life never gives anything for nothing, and that a price is always exacted for what fate bestows.</p>
<p align="right"><i>Marie Antoinette: Bildnis eines mittleren</i></p>
</blockquote>
<p>在我年纪尚小时，平日总喜欢抱着一本书看，大概是为了消遣，也有些文青情怀还未退却。可惜我对文学的热爱并不如何浓郁——它远不能使我埋头案牍皓首穷经，顶多是让我读两本入门门槛不那么高，与他人闲聊时能引那么一两句的图书罢了。而且很明显我的筛选能力也并不强——每当有女孩子看见我在读书，凑过来问一句：“你在读什么书啊？”，不出意外她们总会被书名吓走。即使出了意外，她们也大概率被我接下来尝试概括书本内容的话吓走——这证明我对门槛的判断还是有点高了。</p>
<p>本节开头引的这句话出自斯蒂芬·茨威格的《断头皇后》。很显然，作为一个文青，我应该是在某一期的《意林》或《读者》上看到了这句话然后记了下来；至于这本书，那是万万不可能读的。当然，有些书读完以后，你确实能感觉到整本书唯一有价值的地方就是书封上写的那句“名言”——当然不是这本书，这本书我确实没读过。引这句话的缘由呢，是我一个朋友托我写文记录一件事情，他的事情让我想起了这句话。当然，后面会引的一些语句和写法，提前声明一下，都出于我之手。我的这个朋友是个纯理工直男，半点文学细菌都没有，后面的理工科术语都出自他之口。</p>
<p>故事的开头是惯例的假语村言、真事隐什么的，我们权称我的这个朋友叫yzj吧。早在十余天前，yzj正温温吞吞地赶着自己某门课程的大作业。彼时距ddl尚早，又兼大作业的要求很隐晦，不上手根本掂不出斤两。粗瞟了两眼要求文件的yzj仗着自己学过一点相关课程，会两句C++语法，不免有些飘飘然。尽管老师提醒在先，yzj总觉得自己不算所谓的“很多同学”。后来的事实证明了他的观点，yzj确实不算很多同学，而是正态分布曲线最左边的那一撮。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908023538649_axllra.png"></p>
<p>总而言之，yzj在ddl十余天前才新建了名为finalproject的文件夹，开始了造轮子之旅。起初为了写得顺手，他按照matlab的操作方式写了个矩阵类，这个类重载了很多方法，也写了一些基本的计算，加了很多语法糖。据yzj表示，这是他后面写其他代码时唯一的慰籍，用起来太顺手了。而且这个类一个很大的好处就是漂亮，很好地遵循了设计模式，也针对性能做了很多优化。不过据他反思，在项目完成前就搞优化是大忌，属于新手小白最容易犯的错误之一。这个很漂亮的轮子花了他很多时间，等到他真的开始接触核心计算代码时，时间已经不允许他设计漂亮的类了。</p>
<h2 id="鸡鸣"><a href="#鸡鸣" class="headerlink" title="鸡鸣"></a>鸡鸣</h2><blockquote>
<p>Is life always this hard, or is it just when you’re working on your ddl?</p>
<p>Always like this.</p>
<p align="right"><i>re-creation from Léon</i></p>
</blockquote>
<p>其实设计不了漂亮的类不算一个大问题。虽然就yzj所言，他设计了一个封装地油盐不进丝毫不漏的类用来储存数据，后来才发现很多函数、方法都要用到这里面的数据，不得不设计一个个奇怪的接口以供操作；最后甚至恨不得把private scope改成public scope一劳永逸。然而就笔者来看，这对治疗我这个朋友吹毛求疵的审美洁癖简直是大功一件。而且我这个朋友写出来的拙劣代码，这辈子都不可能有第二个人去看了（哦，除了这门课的可怜助教，may destiny bless him），也免得拖累别人，小问题小问题。</p>
<p>在我看来，更大的问题在于,你要先解决一个问题，然后才再考虑如何漂亮地解决问题。我这个朋友时常拎不清这两者之间的关系。这在平日里他自学一些东西的时候问题倒也不大，有充足的时间拿来处理细节。而且他自学的时候总是拿经典教材一张张地翻过去，这些教材总是事无巨细地列出所有细节，这往往可以解答yzj的困惑。然而实操项目时，问题就变得不可控了起来。遇到的问题往往很偏，也没有足够详细的解决方案；网上的教程多半杂拼乱凑不求甚解，yzj甚至遇到几个Google都没办法解答的bug。这种时候一般人会换个方法或思路，但我这个朋友，他还有强迫症——什么人呐这是——他会继续死磕，直到撞南墙为止。举个例子，yzj一开始想自己写绘图包，尝试了两天发现自己水平不够，于是换了一个开源的绘图包。这个包倒是能跑，可惜太丑，yzj不满意，跑去写python绘图逻辑。写完后他一拍大脑想搞嵌入代码，遂迷之自信地跑去跑去看Cython tutorial，网上的教程很少，也解决不了yzj的问题，他又跑去看Cython Document。被环境变量绕晕后又跑去看CMake Document（他强烈要求我不告诉你们，他一开始还看了几天Makefile Document）。一番下来，几天光阴虚度，项目一点没做。纵观yzj的整个项目流程，基本上都耗在这种细枝末节但往往耗费巨细的地方上了。对了，yzj表示Cython确实很有意思，想填到自己的技术栈里。既然大作业ddl已经结束了，接下来他大概会继续看Cython Document并写些博客笔记什么的吧。</p>
<p>总之我这个朋友身上还有些学生思维没转变过来，这我得好好劝劝他。</p>
<p>站在一个旁人的角度，上面的话语可能有些平淡，好像在讲述一个平平无奇的故事。然而站在当事人的角度，时间的流逝却是无比真切的。每天显示屏左下角的日期都会跳一个数字，这昭示着自己可以拿来赶ddl的时间又少了一天。屏幕左上角的todo-list也总有一两个任务变成红色——这意味着他没有在自己设定的期限前完成这个模块。我的这个朋友，不知道出于压力还是什么原因，停掉了晚上的跑步，和其他人的聊天也会尽快结束掉，每天晚上睡觉越来越迟，第二天中午才能醒来；日常活动也变成了每天两次的取外卖。可惜他发质好，就这样的生活过了几天都不掉头发，殊为可气。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908163738_xhqv9u.jpg"></p>
<h2 id="平旦"><a href="#平旦" class="headerlink" title="平旦"></a>平旦</h2><blockquote>
<p>A half-million years in the future that twinkling of curiosity would have led his mind out into the universe to explore the mathematical mysteries of relativity. Now …</p>
<p align="right"><i>Dragon's Egg</i></p>
</blockquote>
<p>赶ddl的过程的确痛苦，然而当你发现其他人和你一样痛苦的时候，这种痛苦就会无形之中减轻一点。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908165420_zwxqgw.png"></p>
<p>当然，上述表情包纯属开玩笑。在yzj赶ddl中，发现这次大作业确实有点超纲，不少同学都表示难以下手。写累了和同在肝作业的同学&amp;朋友吐槽便成了yzj枯燥生活的少有的乐趣。果然世界上没有真正的感同身受，只有真的经此一劫，yzj才明白苏联笑话为什么会成为世界非遗。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908170757983_gr2gzm.png"></p>
<p>当然，也有大佬比较超脱，靠自己出色的英文文献阅读能力与代码能力一骑绝尘于yzj这等凡夫俗子。他的进度远快于其他人，也在ddl过程中给予了yzj足够的帮助。在此谨代表yzj向他致以深深的respect。</p>
<p>在各种各种调侃和帮助下，yzj还是慢慢地把自己的大作业做了出来。从一开始的望之不似人形的拟合图形到渐渐能看出大概轮廓，再到多少有那么一点感觉。（可以看出最后一张图还是有异常点，可能是出于计算机精度和异常矩阵的原因，或是还有yzj没有考虑到的bug；不过实在太累就没心情调了）</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908200114_dsy4ru.png"></p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114184/QQ%E5%9B%BE%E7%89%8720210908200123_adlhe8.png"></p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114185/QQ%E5%9B%BE%E7%89%8720210908200126_z2hzqn.jpg"></p>
<p>做出效果后，后面的题就好做了很多。前面的成果和轮子也能继续跑下去。yzj用最后仅剩的两三天时间紧赶慢赶地做完了后面的要求。</p>
<h2 id="破晓"><a href="#破晓" class="headerlink" title="破晓"></a>破晓</h2><blockquote>
<p>There is only one heroism in the world: to see the world as it is and to love it.</p>
<p align="right"><i>Romain Rolland</i></p>
</blockquote>
<p>时间来到了9月8日凌晨有余。离交作业的ddl还有约九个小时。这时候，yzj已经实现了大作业的基本要求，然而还有另外一些要求等待实现。“反正都熬了这么多天了，再熬一天把功能做完吧。”yzj心想，随机创建了一个新的header file，打开了文献和Google。</p>
<blockquote>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908204043478_bdmuin.png"></p>
</blockquote>
<p>9月8日凌晨两点，yzj看完论文内的相关算法后又上Google搜了一下成熟的前置算法，发现自己即使刷穿了夜，也可能完不成剩下的内容了。在自己的document里放一个完成了一半，甚至没有可视化和可以供 clients 调用的 interface，纯靠不成体系的代码央求助教给点分实在不大体面。况且主要功能都做出来了，大部分的分都能拿到，索性直接交了，也免得掉头发。于是，yzj把代码又调试了最后一遍，检查了一下自己的document，将它们打包好，邮件发给了助教。粗算了一下，最终文件一共1300行左右的代码量，4.5kb的测试用例（考虑到代码写得实在太烂的因素，有效代码可能要打对折或三分之一）。这的确只是一个小的不能再小的项目代码量了，但对于没多少项目经验的yzj来说，这确实是一个值得一提的挑战。这也提醒了yzj，还是要注意项目经验的积累。</p>
<p>据yzj表示，当他点击了邮箱界面那个小小的【发送】按钮，只觉得浑身的负担一扫而空。他几乎在一瞬间就忘掉了发现自己没办法实现大作业其他要求时的懊恼。这也让他有点想到，让自己这么多天熬夜和自闭的压力究竟来自于哪里。</p>
<p>一身轻后，yzj还是没有什么睡意，于是打开了一个文档，想记录一下自己的心情。yzj刚选上课时，这门课的老师就曾提醒过大家，这门课比较难，需要付出更多的努力，也随之能够获得更多的收获。在上课的过程中，yzj的确感受到了这门课老师想要传道授业的苦心。他一遍又一遍地向大家阐述道：“数学是美的，学数学是探寻美发现美的过程，而非死记硬背的过程。”然而奈何yzj愚且鲁，不能体会到所谓的数学之美。但在做这门大作业的过程中yzj确实学到了很多知识。有了一个代码量合适的可以训练自己 C++ programing language 的机会，也了解了一些和编译器知识，可以和更底层的东西打交道。也被老师安利了linux系统并被深深吸引（linux ubuntu真的超级赞，都去试！）。然而学到这么多东西的过程却并非是在课程中，而是在自己独自做大作业的过程中。这个老师的角色更像是一个鞭策者，用一门有些超纲的大作业促使yzj继续学下去。嗯，其实也有榜样的作用，对yzj来说，这个老师身上的认真，和他对待自己热爱的东西时的态度简直自带光环。</p>
<p><img src="https://res.cloudinary.com/dwy9slegd/image/upload/v1631114183/image-20210908211520814_reitge.png"></p>
<p>约凌晨四点，同样选了这个老师课的室友也完成了自己的大作业。他拍了拍yzj的肩头，轻轻说了声：“我先睡了。”yzj点了点头。看了看窗外，已经有点微曦的晨光了。黎明静悄悄的，只有偶尔传来的极轻微的鸟鸣。</p>
<p>又是新的一天了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>链接器查找范围</title>
    <url>/2021/07/08/lian-jie-qi-cha-zhao-fan-wei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="解决Visual-Studio的-LNK2019-和-LNK1120-错误"><a href="#解决Visual-Studio的-LNK2019-和-LNK1120-错误" class="headerlink" title="解决Visual Studio的 LNK2019 和 LNK1120 错误"></a>解决Visual Studio的 LNK2019 和 LNK1120 错误</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>写了一个 text searching 的代码。该代码设计了数个类，并有一个 interface class 通过指向 base class 的 shared_ptr 通过 dynamic binding 来运行。然而结构设计的不是特别好，这也就导致我遇到了下面的问题：</p>
<span id="more"></span>

<blockquote>
<p>interface class header file：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;, <span class="keyword">const</span> QueryResult &amp;);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>interface class source file</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="keyword">const</span> QueryResult &amp;query) &#123;</span><br><span class="line">	<span class="comment">// details</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>base class header file, which is included by interface class header file</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">		<span class="comment">//下面的语句是错误来源</span></span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">inline</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;, <span class="keyword">const</span> QueryResult &amp;);</span><br><span class="line">		<span class="comment">//details</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接着在尝试运行时就发现了 <a href="https://docs.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2019?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(LNK2019)&rd=true&view=msvc-160">LNK2019</a> 和 <a href="https://docs.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk1120?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(LNK1120)&rd=true&view=msvc-160">LNK1120</a> 错误。以下为错误描述：</p>
<blockquote>
<p>无法解析的外部符号 “class std::basic_ostream&lt;char,struct std::char_traits<char> &gt; &amp; __cdecl operator&lt;&lt;(class std::basic_ostream&lt;char,struct std::char_traits<char> &gt; &amp;,class QueryResult const &amp;)” (??6@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBVQueryResult@@@Z)，函数 main 中引用了该符号</char></char></p>
</blockquote>
<h2 id="尝试分析"><a href="#尝试分析" class="headerlink" title="尝试分析"></a>尝试分析</h2><p>根据错误描述，可以锁定错误出自上面的第一行代码。Visual Studio给出的错误是无法解析，这样一个错误描述有些宽泛，放到 dev cpp 里就会好得多，它的错误提示长下面这样子：</p>
<blockquote>
<p>[警告] inline 函数 ‘std::ostream&amp; 运算符&lt;&lt;(std::ostream&amp;, const QueryResult&amp;)’ used but never defined</p>
</blockquote>
<p>然而我一开始并没有用 dev ，而是自己看 web 调了半天，还找了我的两个同学帮我看了一下。他们的解决方案是把 source file 给 include 进来（这也让我有点吃惊，为什么大二的计科同学会没有 package 的概念）。这样的方案我显然没办法满意，我无法理解，为什么编译器会找不到一个已经 declaration 并且 defining 的函数。出于这种疑惑，我友善地提醒了一下编译器——产生了我的第一个解决方案：</p>
<blockquote>
<p>interface class header file：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;, <span class="keyword">const</span> QueryResult &amp;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>不得不说vs的 MSVC 编译器是真的强大，加个 extern 就能联想到同名的inline函数。如果我没有写这个blog的话，我也许会沾沾自喜于这个解决方案并且依然想破头皮都想不明白为什么会出现这种错误。直到我为了验证这个错误用 dev 上又跑了一遍。我的 dev 编译器是 g++ （版本我也不是很清楚，小白都是一键装环境的），没有这么智能，很实诚地提醒了我。由于 <code>operator&lt;&lt;</code> 函数需要调用 QueryResult object 的 members ，再加上这个函数最开始是在base_Query.h 里 declaration 的，且我的 Query.h has included the base_Query.h，所以编译器找到了 inline 版本的 declaration ，而很不幸，这个函数我没有定义。于是，我得到了第二个解决方案：</p>
<blockquote>
<p>base class header file, which is included by interface class header file</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">		<span class="comment">//该文件前面的 declaration 也要改</span></span><br><span class="line">		<span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;, <span class="keyword">const</span> QueryResult &amp;);</span><br><span class="line">		<span class="comment">//details</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>顺便提一下我的下一个问题：为什么我会在 base_Query.h 里加上 inline 并且在后面的文件里忘记呢？</p>
<p>此事说来话长。我的C++是从《C++ Primer》入门的。在这本书里， Lippman 很细致地讲述了 inline 的作用（也就是没啥作用），但他的示例代码里还是会习惯性地带上 inline ，这个习惯也影响到了我。事实上，我原来的 source file 里全部加了 inline declaration ，这使得我一开始遇到的错误比现在多得多——也同样因为这个原因，我只有将 interface class source file 也 include 进来才能工作。后来一个同学在 STFW （Searching The Fucking Web）后告诉我分离式编程不能使用 inline 。然后这个函数是唯一一个声明了两次的函数，所以被我忘记了（笑）。</p>
<p>关于为什么分离式编程不能使用inline可以看<a href="https://www.cnblogs.com/GodA/p/6554591.html">这里</a>，这个作者讲得非常细致。也希望我有一天能够变成这样的内容输出者。</p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>coding过程中踩过的坑</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ learning notes</title>
    <url>/2021/05/24/c-learning-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="C-learning-notes"><a href="#C-learning-notes" class="headerlink" title="C++ learning notes"></a>C++ learning notes</h1><h2 id="Generic-algorithm"><a href="#Generic-algorithm" class="headerlink" title="Generic algorithm"></a>Generic algorithm</h2><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>[capture list] (parameter list) -&gt; return type {function body}</p>
<p>we can ignore the <em>parameter list</em> and <em>return type</em>, but the <em>capture list</em> and the <em>function body</em> must be reserved</p>
<p>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">const</span> string &amp;a, <span class="keyword">const</span> string &amp;b)</span><br><span class="line">	&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dynamic-memory"><a href="#dynamic-memory" class="headerlink" title="dynamic memory"></a>dynamic memory</h2><h3 id="shared-ptr-lt-gt"><a href="#shared-ptr-lt-gt" class="headerlink" title="shared_ptr&lt;&gt;"></a>shared_ptr&lt;&gt;</h3><p>use function make_shared&lt;&gt;()</p>
<h3 id="unique-ptr-lt-gt"><a href="#unique-ptr-lt-gt" class="headerlink" title="unique_ptr&lt;&gt;"></a>unique_ptr&lt;&gt;</h3><p>must be initialized once the pointer is created</p>
<h3 id="weak-ptr-lt-gt"><a href="#weak-ptr-lt-gt" class="headerlink" title="weak_ptr&lt;&gt;"></a>weak_ptr&lt;&gt;</h3><p>can be assigned</p>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.<span class="built_in">allocate</span>(n);</span><br><span class="line">weak_ptr&lt;string[]&gt; q = p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++ i)&#123;</span><br><span class="line">    alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">	cout &lt;&lt; *(p + i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p,n);</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;		<span class="comment">//provided p points to an object or be nullptr</span></span><br><span class="line"><span class="keyword">delete</span> [] p;	<span class="comment">//provided p points to an array or be nullptr</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Copy-Assign-and-Destroy"><a href="#Copy-Assign-and-Destroy" class="headerlink" title="Copy, Assign and Destroy"></a>Copy, Assign and Destroy</h2><h3 id="specific-member-function-to-control-above-three-operations"><a href="#specific-member-function-to-control-above-three-operations" class="headerlink" title="specific member function to control above three operations"></a>specific member function to control above three operations</h3><p>copy constructor</p>
<p>copy-assignment operator</p>
<p>move constructor</p>
<p>move-assignment operator</p>
<p>destructor</p>
<h3 id="copy-constructor"><a href="#copy-constructor" class="headerlink" title="copy constructor"></a>copy constructor</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	*default defination in class body is inline</span></span><br><span class="line"><span class="comment">    	*if we don&#x27;t hope so, we need to define &quot;= default&quot; out of the class body</span></span><br><span class="line"><span class="comment">    	*generally, function defined in class body is inline</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    	<span class="built_in">Foo</span>() = <span class="keyword">default</span>; <span class="comment">//default constructor</span></span><br><span class="line">		<span class="built_in">Foo</span>(<span class="keyword">const</span> Foo&amp;); <span class="comment">//copy constructor</span></span><br><span class="line">    	<span class="comment">//first parameter must be a reference, and almost always be a const reference</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//explicit prevents implicit conversion</span></span><br><span class="line">    	<span class="function"><span class="keyword">explicit</span> <span class="title">Foo2</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    	<span class="function"><span class="keyword">explicit</span> <span class="title">Foo2</span><span class="params">(<span class="keyword">int</span> num)</span>: n(num) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="copy-assignment-constructor"><a href="#copy-assignment-constructor" class="headerlink" title="copy-assignment constructor"></a>copy-assignment constructor</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*we define a copy-assignment constructor below</span></span><br><span class="line"><span class="comment">    	*keyword operator+symbol is an overloaded operator</span></span><br><span class="line"><span class="comment">    	*which defines an operator(like =,+,- and so on)</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">		Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp; f)&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;n = f-&gt;n;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Foo f1, <span class="built_in">f2</span>(); <span class="comment">//f2 is default initialized</span></span><br><span class="line">    f1 = f2; <span class="comment">//equals to f1(f2)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="stop-the-copy"><a href="#stop-the-copy" class="headerlink" title="stop the copy"></a>stop the copy</h4><p>if we don’t want a copy operation, we need to define it as the <strong>delete function</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *&quot;= delete&quot; must be present when we firstly declare it.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *by the way, we can delete any functions(except the destructor),</span></span><br><span class="line"><span class="comment">        *thongh i haven&#x27;t clearly understood its effect and affect.</span></span><br><span class="line"><span class="comment">        *one interesting and meaningful example is, if a class&#x27;s member</span></span><br><span class="line"><span class="comment">        *can&#x27;t be implicitly initialized, copied, assigned or destroied,</span></span><br><span class="line"><span class="comment">        *its implicit initializer&#x27;s member function is deleted.</span></span><br><span class="line"><span class="comment">        *It prevents from creating indestructible object.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *principle: destructor can&#x27;t be delete</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">NoCopy</span>(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;	<span class="comment">//stop the copy</span></span><br><span class="line">        NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;	<span class="comment">//stop the copy-assignment</span></span><br><span class="line">        ~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *we can put the copy constructor into private zone to prevent from copying it.</span></span><br><span class="line"><span class="comment">        *we need to declare it in the private zone first</span></span><br><span class="line"><span class="comment">        *then define it in the public zone.(in order to prevent friend use it)</span></span><br><span class="line"><span class="comment">        *however, this practice is not recommended.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="destructor"><a href="#destructor" class="headerlink" title="destructor"></a>destructor</h3><p>destructor delete the resource used by objects, and destruct non-static elements</p>
<p>it is used whenever the object is destroyed</p>
<blockquote>
<p>implicitly destruct a pointer won’t delete the object it points.</p>
<p>on the contrary, smart pointer is class type with destructor, thus it can delete the object</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">Foo</span>() = <span class="keyword">default</span>; <span class="comment">//destructor.this function can&#x27;t be overloaded</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="principle"><a href="#principle" class="headerlink" title="principle"></a>principle</h4><ul>
<li>define destructor before assuring weather it needs a destructor or not</li>
<li>if a class needs a copy constructor, it always need a copy-assignment constructor. And vice verse</li>
</ul>
<h3 id="copy-control-and-resource-management"><a href="#copy-control-and-resource-management" class="headerlink" title="copy control and resource management"></a>copy control and resource management</h3><p>behave like a value: the copy and the original object is fully independent</p>
<p>behave like a pointer: the copy and the original object point to the same underlying data</p>
<h4 id="classes-which-behave-like-a-value"><a href="#classes-which-behave-like-a-value" class="headerlink" title="classes which behave like a value"></a>classes which behave like a value</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">			<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">		<span class="comment">//every HasPtr&#x27;s copy has its own string member with equal value</span></span><br><span class="line">		<span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">			<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*(p.ps))), <span class="built_in">i</span>(p.i) &#123;&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*most copy assignment constructor combines the function</span></span><br><span class="line"><span class="comment">		*of destructor and copy constructor.</span></span><br><span class="line"><span class="comment">		*</span></span><br><span class="line"><span class="comment">		*for instance, copy assignment constructor</span></span><br><span class="line"><span class="comment">		*destroys the left side object&#x27;s resource as destructor,</span></span><br><span class="line"><span class="comment">		*and copies data from the right side object</span></span><br><span class="line"><span class="comment">		*to the left one like copy constructor</span></span><br><span class="line"><span class="comment">		*</span></span><br><span class="line"><span class="comment">		*if possible, copy assignment constructor should be exception safe.</span></span><br><span class="line"><span class="comment">		*which means when an exception occurs,</span></span><br><span class="line"><span class="comment">		*it can put the left side object in a meaningful state</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		HasPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">		~<span class="built_in">HasPtr</span>() &#123;</span><br><span class="line">			<span class="keyword">delete</span> ps;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string *ps;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*in this case, to ensure exception safety,</span></span><br><span class="line"><span class="comment">*we copy the right object&#x27;s data first</span></span><br><span class="line"><span class="comment">*to ensure exception safety before assignment.</span></span><br><span class="line"><span class="comment">*then we delete the resource of the left object and execute assignment</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs) &#123;</span><br><span class="line">	<span class="keyword">auto</span> newp = <span class="keyword">new</span> std::<span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">	<span class="keyword">delete</span> ps;</span><br><span class="line">	ps = newp;</span><br><span class="line">	i = rhs.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="classes-which-behave-like-a-pointer"><a href="#classes-which-behave-like-a-pointer" class="headerlink" title="classes which behave like a pointer"></a>classes which behave like a pointer</h4><p>use reference count to control the underlying data</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">			<span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">		<span class="comment">//copy the pointer to ensure they point to the same underlying data</span></span><br><span class="line">		<span class="comment">//increase the reference count</span></span><br><span class="line">		<span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">			<span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123;</span><br><span class="line">			++*use;</span><br><span class="line">		&#125;</span><br><span class="line">		HasPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">		~<span class="built_in">HasPtr</span>();</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string *ps;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		std::<span class="keyword">size_t</span> *use; <span class="comment">//reference count</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::~<span class="built_in">HasPtr</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> ps;</span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs) &#123;</span><br><span class="line">	++*rhs.use;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//execute the left object&#x27;s destructor</span></span><br><span class="line">	<span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> ps;</span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//execute assignment</span></span><br><span class="line">	ps = rhs.ps;</span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>we can swap the pointer to decrease extra memory allocation</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;, HasPtr &amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*if a menber of a class has its own swap function,</span></span><br><span class="line"><span class="comment">*use the std::swap is an error</span></span><br><span class="line"><span class="comment">*and if we implicitly use swap function, the compiler use the overloaded one by default</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span>(lhs.ps,rhs.ps);</span><br><span class="line">	<span class="built_in">swap</span>(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">HasPtr <span class="title">h1</span><span class="params">()</span>,<span class="title">h2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(h1,h2); <span class="comment">//use the overloaded one</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tip:this function can&#x27;t overload the HasPtr &amp;HasPtr::operator=(HasPtr &amp;rhs)</span></span><br><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)&#123; <span class="comment">//parameter is a copy, not a reference</span></span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//rhs is destroyed</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="move-constructor"><a href="#move-constructor" class="headerlink" title="move constructor"></a>move constructor</h3><blockquote>
<p>library container, string and shared_ptr class support both move and copy operation</p>
<p>IO class and unique_ptr class can be moved, but can’t be copied</p>
</blockquote>
<blockquote>
<p>rvalue reference must be bound to an rvalue. we get rvalue reference through &amp;&amp; instead of &amp;</p>
<p>rvalue reference must be bound to an object ready to be destroyed</p>
<p>therefore, we can freely move an rvalue reference resource to another object</p>
<p>moreover, we can bound a const lvalue reference to an rvalue, as well</p>
<p>expression returns an rvalue. But rvalue reference variate itself is a lvalue</p>
<p>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r3 = i * <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r4 = r3; <span class="comment">//illegal</span></span><br></pre></td></tr></table></figure>

<p>all of them is legal except the last one</p>
</blockquote>
<p>std::move avails to use a lvalue as an rvalue. What’s more, we must recognize that executing move means we promote not to use the original element unless we assign or destruct it.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;r4 = std::<span class="built_in">move</span>(r3); <span class="comment">//legal</span></span><br><span class="line"><span class="comment">//use std::move instead of move in order to prevent from potential naming conflict</span></span><br></pre></td></tr></table></figure>

<p>an example of move constructor</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//move operation shouldn&#x27;t throw error</span></span><br><span class="line"><span class="comment">//initializer take over resource of s</span></span><br><span class="line">	: <span class="built_in">elements</span>(s.elements), <span class="built_in">first_feet</span>(s.first_feet), <span class="built_in">cap</span>(s.cap) &#123;</span><br><span class="line">	s.elements = s.first_feet = s.cap = <span class="literal">nullptr</span>; </span><br><span class="line">        							<span class="comment">//brilliant!</span></span><br><span class="line">        							<span class="comment">//get the spark of controlling dynamic memory!</span></span><br><span class="line">	<span class="comment">//now destructing s is safe</span></span><br><span class="line">    <span class="comment">//i wander weather we permit s to be meaningfully assigned, </span></span><br><span class="line">    <span class="comment">//and after insperation, i find that void StrVec::push_back(const std::string &amp;)</span></span><br><span class="line">    <span class="comment">//has considered this situation. Now both assignment and destruction is ligal.</span></span><br><span class="line">    <span class="comment">//and at the same time we can&#x27;t read its value</span></span><br><span class="line">    <span class="comment">//(certainly i put the whole code into my cpp file to avoid making my notes bloated)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="move-assignment-constructor"><a href="#move-assignment-constructor" class="headerlink" title="move assignment constructor"></a>move assignment constructor</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">	<span class="comment">//check self-assignment</span></span><br><span class="line">	<span class="comment">//I guess this operation is designed to avoid freeing itself</span></span><br><span class="line">	<span class="comment">//otherwise it may move meaningless data and put itself in a meaningless state</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">		<span class="built_in">free</span>(); <span class="comment">//release itself</span></span><br><span class="line">		elements = rhs.elements;</span><br><span class="line">		first_feet = rhs.first_feet;</span><br><span class="line">		cap = rhs.cap;</span><br><span class="line">		<span class="comment">//put rhs in a destructible state</span></span><br><span class="line">		rhs.elements = rhs.first_feet = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//copy and move operation&#x27;s overload</span></span><br><span class="line">StrVec v1, v2;</span><br><span class="line">v1 = v2;					<span class="comment">//copy assignment constructor</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream &amp;)</span></span>;	<span class="comment">//getVec returns an rvalue</span></span><br><span class="line">							<span class="comment">//because getVec() dosen&#x27;t return value instead of reference</span></span><br><span class="line">							<span class="comment">//up to now getVec() is just a declaration</span></span><br><span class="line"></span><br><span class="line">v2 = <span class="built_in">getVec</span>(cin);			<span class="comment">//move assignment constructor</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*if we didn&#x27;t define a move constructor</span></span><br><span class="line"><span class="comment">*the compiler will convert an rvalue reference to a const reference</span></span><br><span class="line"><span class="comment">*and call copy constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="reference-qualifier"><a href="#reference-qualifier" class="headerlink" title="reference qualifier"></a>reference qualifier</h3><p>C++ permit us to assign value to a rvalue object(so weird)</p>
<p>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>)</span></span>; 	<span class="comment">//s1 = &quot;a&quot;, s2 = &quot;bbb&quot;;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*(s1 + s2) is an rvalue which never affects s1 and s2&#x27;s value without assignment</span></span><br><span class="line"><span class="comment">*usually it is created by compiler and released soon</span></span><br><span class="line"><span class="comment">*the following expression execute:</span></span><br><span class="line"><span class="comment">*	create a string temp_s = s1 + s2 = &quot;abbb&quot;;</span></span><br><span class="line"><span class="comment">*	assign &quot;Wow&quot; to temp_s and return &quot;Wow&quot;;</span></span><br><span class="line"><span class="comment">*	assign &quot;Wow&quot; to s3;</span></span><br><span class="line"><span class="comment">* 	release temp_s</span></span><br><span class="line"><span class="comment">*Just from my own guess.If there&#x27;s something wrong, I&#x27;ll correct it</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">string s3 = (s1 + s2) = <span class="string">&quot;Wow&quot;</span>;</span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>we can use the reference qualifier to enforce the left object is an lvalue or an rvalue</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//the &amp; in the back of parameter list enforce the left object is an lvalue</span></span><br><span class="line">		Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;; </span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp; rhs) &amp;&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">Foo <span class="title">someMember</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>; <span class="comment">//const should be in front of reference qualifier</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reference qualifier and overloaded</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">		<span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//because object is an rvalue, we can change itself without any affection</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> &amp;&amp;</span>&#123; </span><br><span class="line">	<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//object is an lvalue, thus we can&#x27;t affect its value</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>&#123;</span><br><span class="line">	<span class="function">Foo <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="built_in">sort</span>(temp.data.<span class="built_in">begin</span>(), temp.data.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="overloading-and-type-conversion"><a href="#overloading-and-type-conversion" class="headerlink" title="overloading and type conversion"></a>overloading and type conversion</h2><h3 id="basic-concept"><a href="#basic-concept" class="headerlink" title="basic concept"></a>basic concept</h3><ul>
<li><p>an operator function should be a member of a class or have at least than one class type parameter</p>
</li>
<li><p>which means we can’t overload operators acting on the build-in type</p>
</li>
<li><p>overloaded operator’s priority and associative law is the same as the original operator</p>
</li>
</ul>
<p><strong>operators can be overloaded</strong></p>
<table>
<thead>
<tr>
<th>+</th>
<th>-</th>
<th>*</th>
<th>&#x2F;</th>
<th>%</th>
<th>^</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td></td>
<td></td>
<td>~</td>
<td>!</td>
<td>,</td>
<td>&#x3D;</td>
</tr>
<tr>
<td>&lt;</td>
<td>&gt;</td>
<td>&lt;&#x3D;</td>
<td>&gt;&#x3D;</td>
<td>++</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>&gt;&gt;</td>
<td>&#x3D;&#x3D;</td>
<td>!&#x3D;</td>
<td>&amp;&amp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>-&#x3D;</td>
<td>&#x2F;&#x3D;</td>
<td>%&#x3D;</td>
<td>^&#x3D;</td>
<td>&amp;&#x3D;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&#x3D;</td>
<td>*&#x3D;</td>
<td>&lt;&lt;&#x3D;</td>
<td>&gt;&gt;&#x3D;</td>
<td>[]</td>
<td>()</td>
</tr>
<tr>
<td>-&gt;</td>
<td>-&gt;*</td>
<td>new</td>
<td>new[]</td>
<td>delete</td>
<td>delete[]</td>
<td></td>
</tr>
</tbody></table>
<p><strong>operators can not be overloaded</strong></p>
<table>
<thead>
<tr>
<th>::</th>
<th>.*</th>
<th>.</th>
<th>? :</th>
</tr>
</thead>
</table>
<h3 id="operators"><a href="#operators" class="headerlink" title="operators"></a>operators</h3><p>there are various of operators overloading practice. and you know, <em>cujus rei demonstrationem mirabilem sane detexi. Hanc marginis exiguitas non caperet</em>.(I’m sure I’ve discovered a wonderful demonstration, but the space here is too small to fill it). so I write them all down in my practice .cpp file and just note some announcements there.</p>
<p>The essence of operator overloading is a function call. therefore we can’t save  the original order of evaluation and the short circuit evaluation. and that’s why we don’t advice you to overload comma, address, logic and, logic or.</p>
<p>when we define an operator as a member function, its left operand must be an object of the operator’s class.</p>
<p>operator(&#x3D;), index([]), call(()), member accession(-&gt;) operator must be member function of class.</p>
<p>ostream(&lt;&lt;), istream(&gt;&gt;) can’t be member function.</p>
<p>index operator usually define two overloading versions, the const one and the nonconst one.</p>
<p>increase and decrease operators usually be set as member functions.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strBlobPtr &amp;<span class="keyword">operator</span>++();		<span class="comment">//preoperator</span></span><br><span class="line">strBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);		<span class="comment">//postoperator</span></span><br><span class="line"></span><br><span class="line">strBlobPtr strBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">	strBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if we overload the call operator, the object of this class is called function object, because we can call this object. function object is usually used as actual parameter of generic algorithm. moreover, <a href="https://blog.csdn.net/YangZejia0120/article/details/118713608?spm=1001.2014.3001.5501"><strong>lambda</strong></a> is an unnamed class’ unnamed object, whose call operator is overloaded by lambda’s function body.</p>
<p>liberty <strong>functional</strong> defines a succession of function class as templates. and they are listed below.</p>
<table>
<thead>
<tr>
<th>arithmetic</th>
<th>relation</th>
<th>logic</th>
</tr>
</thead>
<tbody><tr>
<td>plus<Type></Type></td>
<td>equal_to<Type></Type></td>
<td>logical_and<Type></Type></td>
</tr>
<tr>
<td>minus<Type></Type></td>
<td>not_equal_to<Type></Type></td>
<td>logical_or<Type></Type></td>
</tr>
<tr>
<td>multiplies<Type></Type></td>
<td>greater<Type></Type></td>
<td>logical_not<Type></Type></td>
</tr>
<tr>
<td>divides<Type></Type></td>
<td>greater_equal<Type></Type></td>
<td></td>
</tr>
<tr>
<td>modulus<Type></Type></td>
<td>less<Type></Type></td>
<td></td>
</tr>
<tr>
<td>negate<Type></Type></td>
<td>less_equal<Type></Type></td>
<td></td>
</tr>
</tbody></table>
<p>operator <em>type</em>() const is class-type conversions or be named user-define conversions. it allows a type to be an object’s return type. this conversion is implicit.</p>
<p>we can define explicit conversion operator to control class-type conversion.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">SmallInt</span>(<span class="keyword">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i) &#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">		<span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">//explicitly request for type conversion</span></span><br></pre></td></tr></table></figure>

<p>however, if the conversion is used as a condition, the compiler will automatically execute the conversion.</p>
<h3 id="function-table"><a href="#function-table" class="headerlink" title="function table"></a>function table</h3><p>function, function pointer, function class, lambda expression, classes built by bind and any other classes which has overloaded the call operator are all callable object. function class defined in liberty <strong>functional</strong> can be used to reserve callable object.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;</span><br><span class="line"><span class="comment">//f1(4,2) == 6; //equal to add(4,2);</span></span><br><span class="line"><span class="comment">//f1 == true;	//f1 has a callable object;</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> i * j;&#125;;</span><br></pre></td></tr></table></figure>

<p>we can define a function table to reserve callable objects with same <em>retType(args)</em>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">	&#123;<span class="string">&quot;+&quot;</span>, add&#125;,	<span class="comment">//each element is a pair</span></span><br><span class="line">	&#123;<span class="string">&quot;-&quot;</span>, minus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;/&quot;</span>, <span class="built_in">divide</span>()&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;*&quot;</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i * j;&#125;&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;%&quot;</span>, mod&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in this case, binos[&quot;+&quot;](4,2) == 6;</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h2><h3 id="inheritance"><a href="#inheritance" class="headerlink" title="inheritance"></a>inheritance</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Quote</span>(<span class="keyword">const</span> std::string &amp;book, <span class="keyword">double</span> sales_price):</span><br><span class="line">			<span class="built_in">bookNo</span>(book), <span class="built_in">price</span>(sales_price) &#123;&#125;</span><br><span class="line">		<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> bookNo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//key word virtual defines a virtual function</span></span><br><span class="line">		<span class="comment">//which means the base class permits drived classes to override it</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> n * price;</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">//moreover, if we don&#x27;t wish our clients use the base class&#x27; member function</span></span><br><span class="line">    	<span class="comment">//we need to define this member function to be a pure virtual function as the following code row</span></span><br><span class="line">    	<span class="comment">//notice :the pure virtual function can only be defined in the declaration body</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>; <span class="comment">//dynamically bind destructor</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string bookNo;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*key word protected serves for those members</span></span><br><span class="line"><span class="comment">		*which are not supposed to be used by object&#x27;s users</span></span><br><span class="line"><span class="comment">		*but needed to be used by derived class</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">double</span> price = <span class="number">0.0</span>;		<span class="comment">//common price without discount</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*type of class derivation list:colon and a list of base class</span></span><br><span class="line"><span class="comment">*whose type is base class behind optional assess specifire</span></span><br><span class="line"><span class="comment">*and splited by comma</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Buli_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Built_quote</span>(<span class="keyword">const</span> std::string &amp;, <span class="keyword">double</span>, std::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*key word override explicitly declare that this member function</span></span><br><span class="line"><span class="comment">		*will be used to redefine the base class&#x27; virtual function</span></span><br><span class="line"><span class="comment">		*if not, the compiler will throw error</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">//the minimum purchase quantity of discount</span></span><br><span class="line">		std::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>because derived class has its base class member, compiler can implicitly convert it into its base class as a reference or pointer. On the contrary, compiler doesn’t allow us to implicitly convert base class object into derived class object. However, if we ensure this action’s safety, we can use <strong>static_cast</strong> enforce the conversion. But this action is not recommended. What’s more, if the base class has at least one virtual function, we can use <strong>dynamic_cast</strong> to check this conversion’s safety and let the compiler divides whether allow or not.</p>
<p>if a base class defines a static member, the whole inheritance system has only one instance no matter how many derived classes and objects have been defined.</p>
<p>base class must be defined before defining derived classes.</p>
<p>key word <strong>final</strong> restrict us from using a class as base class. key word <strong>final</strong> can be used to declare that a virtual function is the final function, which means this function can’t be overrode.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> &#123;</span><span class="comment">/*details*/</span>&#125;</span><br><span class="line"><span class="comment">//illegal, we can&#x27;t use Noderived as a base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span>:</span> <span class="keyword">public</span> NoDerived &#123;<span class="comment">/*details*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>virtual function can have acquiescent parameters, and its acquiescent parameters depend on the static type of the call.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcion</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">1</span>)</span></span>&#123;<span class="comment">/*details*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a = <span class="number">1</span>, <span class="keyword">int</span> b = <span class="number">2</span>)</span> <span class="keyword">override</span></span>&#123;<span class="comment">/*details*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execuse_function</span><span class="params">(Base &amp;b)</span></span>&#123;</span><br><span class="line">	b.<span class="built_in">function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	<span class="built_in">execuse_function</span>(d); <span class="comment">//execuse Base::function(int a = 0, int b = 1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p><strong>notions:</strong></p>
<ul>
<li>iff the derived class publicly inherits base class can users use the conversions between derived class and base class.</li>
<li>if the derived class publicly or protected inherits base class, the derived class can use the conversions.</li>
<li>if the derived class privately inherits base class, the derived class’ objects and friends can’t use the conversions.</li>
<li>friend relationship can’t be inherited.</li>
<li><strong>each class controls its members’ accessible permissions.</strong></li>
<li>if we need to change a member’s accessible permission, we can use the <em>using</em> declaration in the corresponding action scope</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		std::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//we inherit the base class in the private scope</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//then Base::size() is public </span></span><br><span class="line">		<span class="keyword">using</span> Base::size;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquiescent derived scope operators depend on class’ type. struct acquiescently owns public scope while class having private scope.</p>
<p>derived class’ scope is combined into base class’ scope. thus derived class’ member with the same name as base class’ has higher priority.</p>
<p>name lookup precedes type lookup. function declared in the inner scope won’t override but cover the outer scope’s function.(which remind us to use the <em>override</em> key word. otherwise we must ensure that the derived class’s function has the same parameters list as the base class’)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">memfunc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span> Base&#123;<span class="comment">//Base&#x27;s scope operator is public</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">memfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Base b;</span><br><span class="line">b.<span class="built_in">memfunc</span>();</span><br><span class="line">d.<span class="built_in">memfunc</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">memfunc</span>();		<span class="comment">//error:Base::memfunc() is hided. the right way is written below</span></span><br><span class="line">d.Base::<span class="built_in">memfunc</span>();</span><br></pre></td></tr></table></figure>

<h3 id="dynamic-binding"><a href="#dynamic-binding" class="headerlink" title="dynamic binding"></a>dynamic binding</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//calling Quote::net_price or Bulk_quote::net_price</span></span><br><span class="line">	<span class="comment">//depends on item&#x27;s object type</span></span><br><span class="line">    <span class="comment">//moreover, accessible members which we can use depend on the static type</span></span><br><span class="line">    <span class="comment">//for instance, this item below has no right to use Bulk_quote&#x27;s unique public members</span></span><br><span class="line">	<span class="keyword">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;ISBN: &quot;</span> &lt;&lt; item.<span class="built_in">isbn</span>()</span><br><span class="line">	   &lt;&lt; <span class="string">&quot;# sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if we don&#x27;y want to use dynamic binding, we need to explicitly declare the scope</span></span><br><span class="line"><span class="keyword">double</span> ret = item-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>now, we need to consider this situation where we delete a derived object pointed by a base class pointer. we must ensure that the delete command executes the derived object’s destructor. So we declare the base class’ destructor as a virtual function to solve this problem. what’s more, virtual destructor will impede generating movement operation.</p>
<p>What’s more, if we use containers to save objects, it is supposed to indirectly save it. An common usage is using pointer. Then we are able to use base class pointer calling derived objects.</p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//key word:template</span></span><br><span class="line">  					  <span class="comment">//&lt;template T&gt; is template parameter list</span></span><br><span class="line">					  <span class="comment">//template parameters are divided by comma</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*moerover, key word typename is the same with key word class in this situation</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type parameter can be used as return type or parameter type</span></span><br><span class="line"><span class="comment">//it can be used as variables declaration and type translation, as well</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">	T tmp = *p;</span><br><span class="line">	<span class="comment">//omitted details</span></span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*we can define nontype parameter and the parameter&#x27;s value is provided by</span></span><br><span class="line"><span class="comment">*clients or compiler</span></span><br><span class="line"><span class="comment">*in this case, compiler provide nontype parameters int values depends on</span></span><br><span class="line"><span class="comment">*const char array&#x27;s length</span></span><br><span class="line"><span class="comment">*nontype parameter can be int, object/function pointer or lvalue reference</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*template can be declared as inline or constexpr</span></span><br><span class="line"><span class="comment">*this declaration should be put between template parameter list and return type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>principle</strong>: template function’s parameters are supposed to be const reference, which guarantees non-copyable object’s availability.</p>
<p>if we want to define a class member function out of the class body, it’s type should be:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">return</span>-type class-name::member-<span class="built_in">name</span>(parameter-list) &#123;function-bod&#125;</span><br></pre></td></tr></table></figure>

<p>By default, template class’ member function is instantiated when it is called, which help us to use a template class even though there are some member function incompatible with a type, we can use part of class functions.</p>
<h3 id="friend-declaration"><a href="#friend-declaration" class="headerlink" title="friend declaration"></a>friend declaration</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//friend declaration</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;; <span class="comment">//Pal instantiated by class C is a friend</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span> <span class="comment">//each instantiated Pal2 is C&#x27;s friend</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span><span class="comment">//each instantiated Pal2 is each instantiated C2&#x27;s friend</span></span><br><span class="line">									   <span class="comment">//notice: friend&#x27;s typename should be different from template class&#x27;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span> <span class="comment">//Pal3 is a non-template class, every instantiated C2 is Pal3&#x27;s friend</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//let template&#x27;s typename as friend</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">C3</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> T; <span class="comment">//type T is friend of C3 instantiated by T</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>if a template class contains static members, each type instantiated class has its own static members.</p>
<p>if we access a type name from a template class, we need to use the key word <strong>typename</strong> to explicitly ask compiler treats the name as a type name.</p>
<p>we can define default template argument, like code below.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">compare</span>(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2, F f=<span class="built_in">F</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">f</span>(v1,v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">f</span>(v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//even if all the parameters of a template&#x27;s typename parameter list is default argued</span></span><br><span class="line"><span class="comment">//we have to use angle brackets to ask compiler instantiate a class from a template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt; class tmp_array&#123;<span class="comment">/*details*/</span>&#125;;</span><br><span class="line">tmp_array&lt;&gt; a;</span><br></pre></td></tr></table></figure>

<p>Besides, it is known that once we define a template class’ type, compiler instantiates a class instance. But this activity faces an embarrassing situation. Once we create a project and use template class with the same type in different file, the compiler will instantiates several instances in each file. Which may be a mass overhead. We can use the key word <strong>extern</strong> to declare a class to prevent from such overhead.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;				<span class="comment">//declaration</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;	<span class="comment">//definition</span></span><br><span class="line">												<span class="comment">//in this case, compiler will instantiates the whole members</span></span><br><span class="line">												<span class="comment">//thus the type must apply to every member</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Blob&lt;string&gt; sa1, sa2; <span class="comment">//compiler instantiates class in other file</span></span><br><span class="line">					    <span class="comment">//Thus key word extern expresses that there is a definition in our project</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and if we can’t make sure what the return type definitely is, we can use the tail-set return to declare function’s return type</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using tail-set return to explicitly declare function&#x27;s return type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//details</span></span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reference-collapsing"><a href="#reference-collapsing" class="headerlink" title="reference collapsing:"></a>reference collapsing:</h3><blockquote>
<p>X&amp; &amp;, X&amp; &amp;&amp;, X&amp;&amp; &amp; will collapse to X&amp;</p>
<p>X&amp;&amp; &amp;&amp; will be collapse to X&amp;&amp;</p>
</blockquote>
<p>By define a parameter as an rvalue reference, we can save all of argument’s type-info. By using reference, we can save the const-info. By define parameters as rvalue references, we can use reference collapsing to save arguments’ reference characteristic.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, function expression returns an lvalue, which restrict us from binding an rvalue reference to an rvalue reference. In this case, we need to use the lib function <strong>std::forward</strong>, which is defined in lib <em>utility</em>, to save the reference type(by using the reference collapsing). Thus, we modifies the original code to the below one</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we overload a template function, compiler will chose the more specialized one. Thus if we define a template function</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">func</span><span class="params">(T &amp;a)</span> </span>&#123;<span class="comment">/*details*/</span>&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">func</span><span class="params">(T *a)</span> </span>&#123;<span class="comment">/*details*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>and we hope the compiler may cope with <em>char</em> &amp; <em>const char</em> as <em>string</em>, we need to define two specialized overloaded function</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">func</span><span class="params">(<span class="keyword">const</span> string&amp;)</span></span>; <span class="comment">//declare a string type instance to avoid from default call </span></span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">string</span>(p));&#125;</span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">string</span>(p));&#125;</span><br></pre></td></tr></table></figure>

<h3 id="parameter-packet"><a href="#parameter-packet" class="headerlink" title="parameter packet"></a>parameter packet</h3><p>we use symbol <strong>…</strong> after keyword <em>typename</em> or <em>class</em> to express indefinite number of parameters</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Args is a template parameter packet, rest is a function parameter packet</span></span><br><span class="line"><span class="comment">//Args means zero or several template parameters</span></span><br><span class="line"><span class="comment">//rest means zero or several function parameters</span></span><br><span class="line"><span class="comment">//types in packet can be different from each other</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;T&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(cout, rest)...;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>we can use <strong>sizeof</strong> to calculate the number of parameters in the packet</p>
<p><strong>call packet parameters</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//end the recursion and print the last element</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//recursion call</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">2.0</span>;</span><br><span class="line">	<span class="keyword">long</span> l = <span class="number">321</span>;</span><br><span class="line">	string s = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	<span class="built_in">foo</span>(cout, i, d, l, s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:1       2       321     hello world!</span></span><br></pre></td></tr></table></figure>

<h3 id="specialize"><a href="#specialize" class="headerlink" title="specialize"></a>specialize</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//specialize</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>(&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span>(&amp;)[M])</span></span>; <span class="comment">//const char(&amp;)[M] is a reference to an char array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a specialized instance of function compare</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> &amp;, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> &amp;)</span></span>;<span class="comment">//a reference to an const (or not) pointer</span></span><br></pre></td></tr></table></figure>

<p><strong>notice</strong>: Once we need a specialized instance but forget to declare or define one, where there is a template suits to this instance’s type, the compiler will instantiate an instance. This mistake won’t be checked up. Thus we are supposed to define templates with the same name in the same header file. And put the specialized instances after those template. Certainly we need to check up whether we have declared an instance or not.</p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
</search>
